./src/higher-level/texture-hl.c:int prodlen[7] = { phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature };
./src/higher-level/texture-hl.c:bool enable[7] = {  phl->txt.oero, phl->txt.odil, phl->txt.oopn, phl->txt.ocls, 
./src/higher-level/texture-hl.c:                    phl->txt.ogrd, phl->txt.otht, phl->txt.obht };
./src/higher-level/texture-hl.c:bool write[7]  = { phl->txt.oero, phl->txt.odil, phl->txt.oopn, phl->txt.ocls, 
./src/higher-level/texture-hl.c:                   phl->txt.ogrd, phl->txt.otht, phl->txt.obht };
./src/higher-level/texture-hl.c:          basename_without_ext(phl->ftr.bname[b], bname, NPOW_10);
./src/higher-level/texture-hl.c:            nchar = snprintf(domain, NPOW_10, "%s_B%04d", bname, phl->ftr.band[b]);
./src/higher-level/texture-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/texture-hl.c:  nchar = snprintf(fname, NPOW_10, "%s_HL_TXT_%s", phl->txt.base, prodname);
./src/higher-level/texture-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/texture-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/texture-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/texture-hl.c:                     Size(2*phl->txt.radius+1, 2*phl->txt.radius+1),
./src/higher-level/texture-hl.c:                     Point(phl->txt.radius, phl->txt.radius));
./src/higher-level/texture-hl.c:      if (phl->txt.oero) morphologyEx(src, ero_dst, MORPH_ERODE,    morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:      if (phl->txt.odil) morphologyEx(src, dil_dst, MORPH_DILATE,   morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:      if (phl->txt.oopn) morphologyEx(src, opn_dst, MORPH_OPEN,     morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:      if (phl->txt.ocls) morphologyEx(src, cls_dst, MORPH_CLOSE,    morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:      if (phl->txt.ogrd) morphologyEx(src, grd_dst, MORPH_GRADIENT, morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:      if (phl->txt.otht) morphologyEx(src, tht_dst, MORPH_TOPHAT,   morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:      if (phl->txt.obht) morphologyEx(src, bht_dst, MORPH_BLACKHAT, morph_elem, Point(-1,-1), phl->txt.iter);
./src/higher-level/texture-hl.c:        if (!features[f].msk[p] && phl->ftr.exclude){
./src/higher-level/texture-hl.c:          if (phl->txt.oero) txt.ero_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.odil) txt.dil_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.oopn) txt.opn_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.ocls) txt.cls_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.ogrd) txt.grd_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.otht) txt.tht_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.obht) txt.bht_[f][p] = nodata;
./src/higher-level/texture-hl.c:          if (phl->txt.oero) txt.ero_[f][p] = ero_dst.at<short>(i,j);
./src/higher-level/texture-hl.c:          if (phl->txt.odil) txt.dil_[f][p] = dil_dst.at<short>(i,j);
./src/higher-level/texture-hl.c:          if (phl->txt.oopn) txt.opn_[f][p] = opn_dst.at<short>(i,j);
./src/higher-level/texture-hl.c:          if (phl->txt.ocls) txt.cls_[f][p] = cls_dst.at<short>(i,j);
./src/higher-level/texture-hl.c:          if (phl->txt.ogrd) txt.grd_[f][p] = grd_dst.at<short>(i,j);
./src/higher-level/texture-hl.c:          if (phl->txt.otht) txt.tht_[f][p] = tht_dst.at<short>(i,j);
./src/higher-level/texture-hl.c:          if (phl->txt.obht) txt.bht_[f][p] = bht_dst.at<short>(i,j);
./src/higher-level/cf-improphe-hl.c:  prodlen = phl->cfi.nyears;
./src/higher-level/cf-improphe-hl.c:    basename_without_ext(phl->con.fname[o], bname, NPOW_10);
./src/higher-level/cf-improphe-hl.c:        set_date_year(&date, phl->cfi.years[b]);
./src/higher-level/cf-improphe-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/cf-improphe-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/cf-improphe-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/cf-improphe-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/cf-improphe-hl.c:  for (y=0; y<phl->cfi.nyears; y++){
./src/higher-level/cf-improphe-hl.c:    if ((b_cf = phl->cfi.years[y]-phl->cfi.y0) >= ny_cf){
./src/higher-level/cf-improphe-hl.c:  width = phl->imp.ksize*2+1;
./src/higher-level/cf-improphe-hl.c:  printf("radius/width/nkernel/minnum: %d/%d/%d/%d\n", phl->imp.ksize, width, nk, mink);
./src/higher-level/cf-improphe-hl.c:  for (y=0; y<phl->cfi.nyears; y++){
./src/higher-level/cf-improphe-hl.c:    b_cf = phl->cfi.years[y]-phl->cfi.y0;
./src/higher-level/cf-improphe-hl.c:    if ((seasonal_avg_ = average_season(ard, mask_, nb_ard, nc, nt, ard_nodata, phl->imp.nwin, phl->imp.dwin, phl->cfi.years[y], &is_empty)) == NULL){
./src/higher-level/cf-improphe-hl.c:    if ((ard_ = pca(seasonal_avg_, mask_, phl->imp.nwin*nb_ard, nc, ard_nodata, 0.975, &npc)) == NULL){
./src/higher-level/cf-improphe-hl.c:    free_2D((void**)seasonal_avg_, phl->imp.nwin*nb_ard);
./src/higher-level/cf-improphe-hl.c:    if ((ard_tex_ = focal_sd(ard_, ard_nodata, phl->imp.ksd, nx, ny, npc, 0)) == NULL){
./src/higher-level/cf-improphe-hl.c:      if ((cf_tex_[f] = focal_sd(cf_, cf_nodata, phl->imp.ksd, nx, ny, 1, f)) == NULL){
./src/higher-level/cf-improphe-hl.c:          nx, ny, phl->imp.ksize, npc, ncf, nk, mink);
./src/higher-level/trend-hl.c:  trend(ts->fby_, ts->d_fby, mask_, nc, phl->ny, ts->try_, nodata, _FLD_YEAR_,    in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  trend(ts->fbq_, ts->d_fbq, mask_, nc, phl->nq, ts->trq_, nodata, _FLD_QUARTER_, in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  trend(ts->fbm_, ts->d_fbm, mask_, nc, phl->nm, ts->trm_, nodata, _FLD_MONTH_,   in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  trend(ts->fbw_, ts->d_fbw, mask_, nc, phl->nw, ts->trw_, nodata, _FLD_WEEK_,    in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  trend(ts->fbd_, ts->d_fbd, mask_, nc, phl->nd, ts->trd_, nodata, _FLD_DOY_,     in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  if (phl->tsa.lsp.otrd){
./src/higher-level/trend-hl.c:      trend(ts->lsp_[l], ts->d_lsp, mask_, nc, phl->tsa.lsp.ny, ts->trp_[l], nodata, _FLD_YEAR_, in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  if (phl->tsa.pol.otrd){
./src/higher-level/trend-hl.c:      trend(ts->pol_[l], ts->d_pol, mask_, nc, phl->tsa.pol.ny, ts->tro_[l], nodata, _FLD_YEAR_, in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  cat(ts->fby_, ts->d_fby, mask_, nc, phl->ny, ts->cay_, nodata, _FLD_YEAR_,    in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  cat(ts->fbq_, ts->d_fbq, mask_, nc, phl->nq, ts->caq_, nodata, _FLD_QUARTER_, in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  cat(ts->fbm_, ts->d_fbm, mask_, nc, phl->nm, ts->cam_, nodata, _FLD_MONTH_,   in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  cat(ts->fbw_, ts->d_fbw, mask_, nc, phl->nw, ts->caw_, nodata, _FLD_WEEK_,    in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  cat(ts->fbd_, ts->d_fbd, mask_, nc, phl->nd, ts->cad_, nodata, _FLD_DOY_,     in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  if (phl->tsa.lsp.ocat){
./src/higher-level/trend-hl.c:      cat(ts->lsp_[l], ts->d_lsp, mask_, nc, phl->tsa.lsp.ny, ts->cap_[l], nodata, _FLD_YEAR_, in_ce, &phl->tsa.trd);
./src/higher-level/trend-hl.c:  if (phl->tsa.pol.ocat){
./src/higher-level/trend-hl.c:      cat(ts->pol_[l], ts->d_pol, mask_, nc, phl->tsa.pol.ny, ts->cao_[l], nodata, _FLD_YEAR_, in_ce, &phl->tsa.trd);
./src/higher-level/_higher-level.c:  copy_string(phl->f_par, NPOW_10, args.fprm);
./src/higher-level/_higher-level.c:  if ((cube = copy_datacube_def(phl->d_lower, phl->d_higher, phl->blocksize)) == NULL){
./src/higher-level/_higher-level.c:  update_datacube_extent(cube, phl->tx[_MIN_], phl->tx[_MAX_], phl->ty[_MIN_], phl->ty[_MAX_]);
./src/higher-level/_higher-level.c:  update_datacube_res(cube, phl->res);
./src/higher-level/_higher-level.c:  if (tile_active(phl->f_tile, cube) == FAILURE){
./src/higher-level/_higher-level.c:  if (omp_get_thread_limit() < (phl->ithread+phl->othread+phl->cthread)){
./src/higher-level/_higher-level.c:  cite_push(phl->d_higher);
./src/higher-level/cso-hl.c:int o, nprod = phl->cso.sta.nmetrics;
./src/higher-level/cso-hl.c:  if (phl->cso.sta.num > -1) copy_string(prodname[phl->cso.sta.num], NPOW_03, "NUM");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.min > -1) copy_string(prodname[phl->cso.sta.min], NPOW_03, "MIN");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.max > -1) copy_string(prodname[phl->cso.sta.max], NPOW_03, "MAX");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.rng > -1) copy_string(prodname[phl->cso.sta.rng], NPOW_03, "RNG");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.iqr > -1) copy_string(prodname[phl->cso.sta.iqr], NPOW_03, "IQR");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.avg > -1) copy_string(prodname[phl->cso.sta.avg], NPOW_03, "AVG");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.std > -1) copy_string(prodname[phl->cso.sta.std], NPOW_03, "STD");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.skw > -1) copy_string(prodname[phl->cso.sta.skw], NPOW_03, "SKW");
./src/higher-level/cso-hl.c:  if (phl->cso.sta.krt > -1) copy_string(prodname[phl->cso.sta.krt], NPOW_03, "KRT");
./src/higher-level/cso-hl.c:  for (q=0; q<phl->cso.sta.nquantiles; q++){
./src/higher-level/cso-hl.c:    nchar = snprintf(prodname[phl->cso.sta.qxx[q]], NPOW_03, "Q%02.0f", phl->cso.sta.q[q]*100);
./src/higher-level/cso-hl.c:      year = phl->date_range[_MIN_].year;
./src/higher-level/cso-hl.c:      month = phl->date_range[_MIN_].month;
./src/higher-level/cso-hl.c:        month += phl->cso.step;
./src/higher-level/cso-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/cso-hl.c:    phl->date_range[_MIN_].year, phl->date_range[_MAX_].year, 
./src/higher-level/cso-hl.c:    phl->doy_range[_MIN_], phl->doy_range[_MAX_], 
./src/higher-level/cso-hl.c:    phl->cso.step, phl->sen.target, prodname);
./src/higher-level/cso-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/cso-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/cso-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/cso-hl.c:  year  = phl->date_range[_MIN_].year;
./src/higher-level/cso-hl.c:  month = phl->date_range[_MIN_].month;
./src/higher-level/cso-hl.c:  while (year < phl->date_range[_MAX_].year ||
./src/higher-level/cso-hl.c:        (year <= phl->date_range[_MAX_].year && month < phl->date_range[_MAX_].month)){
./src/higher-level/cso-hl.c:    if ((month += phl->cso.step) > 12){ year++; month -= 12;}
./src/higher-level/cso-hl.c:  if (phl->cso.sta.quantiles || phl->cso.sta.iqr > -1) alloc_q_array = true;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.num > -1) cs.cso_[phl->cso.sta.num][w][p] = n;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.min > -1) cs.cso_[phl->cso.sta.min][w][p] = minimum;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.max > -1) cs.cso_[phl->cso.sta.max][w][p] = maximum;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.rng > -1) cs.cso_[phl->cso.sta.rng][w][p] = maximum-minimum;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.avg > -1) cs.cso_[phl->cso.sta.avg][w][p] = (short)mean;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.std > -1) cs.cso_[phl->cso.sta.std][w][p] = (short)standdev(var, n);
./src/higher-level/cso-hl.c:        if (phl->cso.sta.skw > -1) cs.cso_[phl->cso.sta.skw][w][p] = (short)skewscaled;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.krt > -1) cs.cso_[phl->cso.sta.krt][w][p] = (short)kurtscaled;
./src/higher-level/cso-hl.c:        if (phl->cso.sta.quantiles){
./src/higher-level/cso-hl.c:          for (q=0; q<phl->cso.sta.nquantiles; q++){
./src/higher-level/cso-hl.c:            cs.cso_[phl->cso.sta.qxx[q]][w][p] = (short)quantile(q_array, n, phl->cso.sta.q[q]);
./src/higher-level/cso-hl.c:            if (phl->cso.sta.q[q] == 0.25) q25_ = cs.cso_[phl->cso.sta.qxx[q]][w][p];
./src/higher-level/cso-hl.c:            if (phl->cso.sta.q[q] == 0.75) q75_ = cs.cso_[phl->cso.sta.qxx[q]][w][p];
./src/higher-level/cso-hl.c:        if (phl->cso.sta.iqr > -1){
./src/higher-level/cso-hl.c:          cs.cso_[phl->cso.sta.iqr][w][p] = q75_-q25_;
./src/higher-level/progress-hl.c:  pro->thread[_TASK_INPUT_]   = phl->ithread;
./src/higher-level/progress-hl.c:  pro->thread[_TASK_COMPUTE_] = phl->cthread;
./src/higher-level/progress-hl.c:  pro->thread[_TASK_OUTPUT_]  = phl->othread;
./src/higher-level/progress-hl.c:  pro->thread[_TASK_ALL_]     = phl->ithread+phl->cthread+phl->othread;
./src/higher-level/progress-hl.c:  pro->thread[_TASK_RUNTIME_] = phl->ithread+phl->cthread+phl->othread;
./src/higher-level/param-hl.c:  register_char_par(params,    "DIR_LOWER",  _CHAR_TEST_EXIST_,         &phl->d_lower);
./src/higher-level/param-hl.c:  register_char_par(params,    "DIR_HIGHER", _CHAR_TEST_EXIST_,         &phl->d_higher);
./src/higher-level/param-hl.c:  register_char_par(params,    "DIR_MASK",   _CHAR_TEST_NULL_OR_EXIST_, &phl->d_mask);
./src/higher-level/param-hl.c:  register_char_par(params,    "BASE_MASK",  _CHAR_TEST_NULL_OR_BASE_,  &phl->b_mask);
./src/higher-level/param-hl.c:  register_char_par(params,    "FILE_TILE",  _CHAR_TEST_NULL_OR_EXIST_, &phl->f_tile);
./src/higher-level/param-hl.c:  register_intvec_par(params,  "X_TILE_RANGE", -999, 9999, &phl->tx, &phl->ntx);
./src/higher-level/param-hl.c:  register_intvec_par(params,  "Y_TILE_RANGE", -999, 9999, &phl->ty, &phl->nty);
./src/higher-level/param-hl.c:  register_double_par(params,  "RESOLUTION", 0, FLT_MAX, &phl->res);
./src/higher-level/param-hl.c:  register_double_par(params,  "BLOCK_SIZE", 0, FLT_MAX, &phl->blocksize);
./src/higher-level/param-hl.c:  register_char_par(params,    "FILE_OUTPUT_OPTIONS",   _CHAR_TEST_NULL_OR_EXIST_, &phl->f_gdalopt);
./src/higher-level/param-hl.c:  register_enum_par(params,    "OUTPUT_FORMAT",  _TAGGED_ENUM_FMT_, _FMT_LENGTH_, &phl->format);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_EXPLODE", &phl->explode);
./src/higher-level/param-hl.c:  //register_bool_par(params,    "OUTPUT_OVERWRITE", &phl->owr);
./src/higher-level/param-hl.c:  register_int_par(params,     "NTHREAD_READ",    1, INT_MAX, &phl->ithread);
./src/higher-level/param-hl.c:  register_int_par(params,     "NTHREAD_WRITE",   1, INT_MAX, &phl->othread);
./src/higher-level/param-hl.c:  register_int_par(params,     "NTHREAD_COMPUTE", 1, INT_MAX, &phl->cthread);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "SENSORS", _TAGGED_ENUM_SEN_, _SEN_LENGTH_, &phl->sen.senid, &phl->sen.n);
./src/higher-level/param-hl.c:  register_bool_par(params,    "SPECTRAL_ADJUST", &phl->sen.spec_adjust);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "SCREEN_QAI", _TAGGED_ENUM_QAI_, _QAI_LENGTH_, &phl->qai.flags, &phl->qai.nflags);
./src/higher-level/param-hl.c:  register_datevec_par(params, "DATE_RANGE", "1900-01-01", "2099-12-31", &phl->date_range, &phl->ndate);
./src/higher-level/param-hl.c:  register_intvec_par(params,  "DOY_RANGE", 1, 365, &phl->doy_range, &phl->ndoy);
./src/higher-level/param-hl.c:  register_bool_par(params,    "REDUCE_PSF",      &phl->psf);
./src/higher-level/param-hl.c:  register_bool_par(params,    "USE_L2_IMPROPHE", &phl->prd.imp);
./src/higher-level/param-hl.c:  register_float_par(params,   "ABOVE_NOISE", 0, FLT_MAX, &phl->qai.above_noise);
./src/higher-level/param-hl.c:  register_float_par(params,   "BELOW_NOISE", 0, FLT_MAX, &phl->qai.below_noise);
./src/higher-level/param-hl.c:  register_int_par(params,   "YEAR_TARGET", 1900, 2100, &phl->bap.Yt);
./src/higher-level/param-hl.c:  register_int_par(params,   "YEAR_NUM", 0, 100, &phl->bap.Yr);
./src/higher-level/param-hl.c:  register_float_par(params, "Y_FACTOR", 0, FLT_MAX, &phl->bap.Yf);
./src/higher-level/param-hl.c:  register_floatvec_par(params, "DOY_SCORE", 0, 1, &phl->bap.Ds, &phl->bap.nDs);
./src/higher-level/param-hl.c:  register_intvec_par(params,   "DOY_STATIC", 1, 365, &phl->bap.Dt, &phl->bap.nDt);
./src/higher-level/param-hl.c:  register_bool_par(params,  "OFF_SEASON", &phl->bap.offsea);
./src/higher-level/param-hl.c:  register_float_par(params, "DREQ", 1, FLT_MAX, &phl->bap.dreq);
./src/higher-level/param-hl.c:  register_float_par(params, "VREQ", 1, 90, &phl->bap.vreq);
./src/higher-level/param-hl.c:  register_bool_par(params,   "OUTPUT_BAP", &phl->bap.obap);
./src/higher-level/param-hl.c:  register_bool_par(params,   "OUTPUT_INF", &phl->bap.oinf);
./src/higher-level/param-hl.c:  register_bool_par(params,   "OUTPUT_SCR", &phl->bap.oscr);
./src/higher-level/param-hl.c:  register_bool_par(params,   "OUTPUT_OVV", &phl->bap.oovv);
./src/higher-level/param-hl.c:  register_float_par(params, "SCORE_DOY_WEIGHT",    0, 1, &phl->bap.w.d);
./src/higher-level/param-hl.c:  register_float_par(params, "SCORE_YEAR_WEIGHT",   0, 1, &phl->bap.w.y);
./src/higher-level/param-hl.c:  register_float_par(params, "SCORE_CLOUD_WEIGHT",  0, 1, &phl->bap.w.c);
./src/higher-level/param-hl.c:  register_float_par(params, "SCORE_HAZE_WEIGHT",   0, 1, &phl->bap.w.h);
./src/higher-level/param-hl.c:  register_float_par(params, "SCORE_CORREL_WEIGHT", 0, 1, &phl->bap.w.r);
./src/higher-level/param-hl.c:  register_float_par(params, "SCORE_VZEN_WEIGHT",   0, 1, &phl->bap.w.v);
./src/higher-level/param-hl.c:  register_char_par(params,    "DIR_LSP", _CHAR_TEST_NULL_OR_EXIST_, &phl->con.dname);
./src/higher-level/param-hl.c:  register_charvec_par(params, "BASE_LSP", _CHAR_TEST_NULL_OR_BASE_, &phl->con.fname, &phl->con.n);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSP_NODATA", SHRT_MIN, SHRT_MAX, &phl->con.nodata);
./src/higher-level/param-hl.c:  register_bool_par(params,    "LSP_DO", &phl->bap.pac.lsp);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSP_1ST_YEAR", 1900, 2100, &phl->bap.pac.y0);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSP_START", 1, 2100*365, &phl->bap.pac.start);
./src/higher-level/param-hl.c:  register_float_par(params,   "LSP_THRESHOLD", 0, 365, &phl->bap.pac.rmse);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "INDEX", _TAGGED_ENUM_IDX_, _IDX_LENGTH_, &phl->tsa.index, &phl->tsa.n);
./src/higher-level/param-hl.c:  register_enum_par(params,    "STANDARDIZE_TSS", _TAGGED_ENUM_STD_, _STD_LENGTH_, &phl->tsa.standard);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_TSS", &phl->tsa.otss);
./src/higher-level/param-hl.c:  register_char_par(params, "FILE_ENDMEM",    _CHAR_TEST_NULL_OR_EXIST_, &phl->tsa.sma.f_emb);
./src/higher-level/param-hl.c:  register_bool_par(params, "SMA_SUM_TO_ONE", &phl->tsa.sma.sto);
./src/higher-level/param-hl.c:  register_bool_par(params, "SMA_NON_NEG",    &phl->tsa.sma.pos);
./src/higher-level/param-hl.c:  register_bool_par(params, "SMA_SHD_NORM",   &phl->tsa.sma.shn);
./src/higher-level/param-hl.c:  register_int_par(params,  "SMA_ENDMEMBER",  0, INT_MAX, &phl->tsa.sma.emb);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_RMS",     &phl->tsa.sma.orms);
./src/higher-level/param-hl.c:  register_enum_par(params,   "INTERPOLATE", _TAGGED_ENUM_INT_, _INT_LENGTH_, &phl->tsa.tsi.method);
./src/higher-level/param-hl.c:  register_int_par(params,    "MOVING_MAX",  1, 365, &phl->tsa.tsi.mov_max);
./src/higher-level/param-hl.c:  register_intvec_par(params, "RBF_SIGMA",   1, 365, &phl->tsa.tsi.rbf_sigma, &phl->tsa.tsi.rbf_nk);
./src/higher-level/param-hl.c:  register_float_par(params,  "RBF_CUTOFF",  0, 1, &phl->tsa.tsi.rbf_cutoff);
./src/higher-level/param-hl.c:  register_int_par(params,    "INT_DAY",     1, INT_MAX, &phl->tsa.tsi.step);
./src/higher-level/param-hl.c:  register_enum_par(params,   "STANDARDIZE_TSI", _TAGGED_ENUM_STD_, _STD_LENGTH_, &phl->tsa.tsi.standard);
./src/higher-level/param-hl.c:  register_bool_par(params,   "OUTPUT_TSI",  &phl->tsa.tsi.otsi);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "STM", _TAGGED_ENUM_STA_, _STA_LENGTH_, &phl->tsa.stm.sta.metrics, &phl->tsa.stm.sta.nmetrics);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_STM", &phl->tsa.stm.ostm);
./src/higher-level/param-hl.c:  register_enum_par(params, "FOLD_TYPE", _TAGGED_ENUM_STA_, _STA_LENGTH_, &phl->tsa.fld.type);
./src/higher-level/param-hl.c:  register_enum_par(params, "STANDARDIZE_FOLD", _TAGGED_ENUM_STD_, _STD_LENGTH_, &phl->tsa.fld.standard);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_FBY", &phl->tsa.fld.ofby);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_FBQ", &phl->tsa.fld.ofbq);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_FBM", &phl->tsa.fld.ofbm);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_FBW", &phl->tsa.fld.ofbw);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_FBD", &phl->tsa.fld.ofbd);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_TRY", &phl->tsa.fld.otry);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_TRQ", &phl->tsa.fld.otrq);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_TRM", &phl->tsa.fld.otrm);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_TRW", &phl->tsa.fld.otrw);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_TRD", &phl->tsa.fld.otrd);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_CAY", &phl->tsa.fld.ocay);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_CAQ", &phl->tsa.fld.ocaq);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_CAM", &phl->tsa.fld.ocam);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_CAW", &phl->tsa.fld.ocaw);
./src/higher-level/param-hl.c:  register_bool_par(params, "OUTPUT_CAD", &phl->tsa.fld.ocad);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSP_DOY_PREV_YEAR", 1, 365, &phl->tsa.lsp.dprev);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSP_DOY_NEXT_YEAR", 1, 365, &phl->tsa.lsp.dnext);
./src/higher-level/param-hl.c:  register_enum_par(params,    "LSP_HEMISPHERE", _TAGGED_ENUM_HEMI_, _HEMI_LENGTH_, &phl->tsa.lsp.hemi);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSP_N_SEGMENT",     1, INT_MAX, &phl->tsa.lsp.nseg);
./src/higher-level/param-hl.c:  register_float_par(params,   "LSP_AMP_THRESHOLD", 0.01, 0.99, &phl->tsa.lsp.start);
./src/higher-level/param-hl.c:  register_float_par(params,   "LSP_MIN_VALUE",     -10000, 10000, &phl->tsa.lsp.minval);
./src/higher-level/param-hl.c:  register_float_par(params,   "LSP_MIN_AMPLITUDE", 0, 10000, &phl->tsa.lsp.minamp);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "LSP", _TAGGED_ENUM_LSP_, _LSP_LENGTH_, &phl->tsa.lsp.metrics, &phl->tsa.lsp.nmetrics);
./src/higher-level/param-hl.c:  register_enum_par(params,    "STANDARDIZE_LSP", _TAGGED_ENUM_STD_, _STD_LENGTH_, &phl->tsa.lsp.standard);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_SPL",        &phl->tsa.lsp.ospl);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_LSP",        &phl->tsa.lsp.olsp);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_TRP",        &phl->tsa.lsp.otrd);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_CAP",        &phl->tsa.lsp.ocat);
./src/higher-level/param-hl.c:  register_float_par(params,   "POL_START_THRESHOLD", 0.01, 0.99, &phl->tsa.pol.start);
./src/higher-level/param-hl.c:  register_float_par(params,   "POL_MID_THRESHOLD",   0.01, 0.99, &phl->tsa.pol.mid);
./src/higher-level/param-hl.c:  register_float_par(params,   "POL_END_THRESHOLD",   0.01, 0.99, &phl->tsa.pol.end);
./src/higher-level/param-hl.c:  register_bool_par(params,    "POL_ADAPTIVE",        &phl->tsa.pol.adaptive);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "POL", _TAGGED_ENUM_POL_, _POL_LENGTH_, &phl->tsa.pol.metrics, &phl->tsa.pol.nmetrics);
./src/higher-level/param-hl.c:  register_enum_par(params,    "STANDARDIZE_POL", _TAGGED_ENUM_STD_, _STD_LENGTH_, &phl->tsa.pol.standard);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_PCT",        &phl->tsa.pol.opct);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_POL",        &phl->tsa.pol.opol);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_TRO",        &phl->tsa.pol.otrd);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_CAO",        &phl->tsa.pol.ocat);
./src/higher-level/param-hl.c:  register_enum_par(params,  "TREND_TAIL", _TAGGED_ENUM_TAIL_, _TAIL_LENGTH_, &phl->tsa.trd.tail);
./src/higher-level/param-hl.c:  register_float_par(params, "TREND_CONF", 0, 1, &phl->tsa.trd.conf);
./src/higher-level/param-hl.c:  register_bool_par(params,  "CHANGE_PENALTY", &phl->tsa.trd.penalty);
./src/higher-level/param-hl.c:  register_char_par(params,    "FILE_PYTHON",  _CHAR_TEST_NULL_OR_EXIST_, &phl->tsa.pyp.f_code);
./src/higher-level/param-hl.c:  register_enum_par(params,    "PYTHON_TYPE",  _TAGGED_ENUM_UDF_, _UDF_LENGTH_, &phl->tsa.pyp.type);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_PYP",    &phl->tsa.pyp.out);
./src/higher-level/param-hl.c:  register_int_par(params,     "MONTH_STEP", 1, 12, &phl->cso.step);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "CSO", _TAGGED_ENUM_STA_, _STA_LENGTH_, &phl->cso.sta.metrics, &phl->cso.sta.nmetrics);
./src/higher-level/param-hl.c:  register_intvec_par(params,  "SEASONAL_WINDOW",      1, 365, &phl->imp.dwin, &phl->imp.bwin);
./src/higher-level/param-hl.c:  register_double_par(params,  "KERNEL_SIZE",          0, 1e6, &phl->imp.pred_radius);
./src/higher-level/param-hl.c:  register_double_par(params,  "KERNEL_TEXT",          0, 1e6, &phl->imp.text_radius);
./src/higher-level/param-hl.c:  register_char_par(params,    "DIR_COARSE",  _CHAR_TEST_NULL_OR_EXIST_, &phl->con.dname);
./src/higher-level/param-hl.c:  register_charvec_par(params, "BASE_COARSE", _CHAR_TEST_BASE_, &phl->con.fname, &phl->con.n);
./src/higher-level/param-hl.c:  register_int_par(params,     "COARSE_NODATA", SHRT_MIN, SHRT_MAX, &phl->con.nodata);
./src/higher-level/param-hl.c:  register_int_par(params,     "COARSE_1ST_YEAR",      1900, 2100, &phl->cfi.y0);
./src/higher-level/param-hl.c:  register_intvec_par(params,  "COARSE_PREDICT_YEARS", 1900, 2100, &phl->cfi.years, &phl->cfi.nyears);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "SENSORS_LOWRES", _TAGGED_ENUM_SEN_, _SEN_LENGTH_, &phl->sen2.senid, &phl->sen2.n);
./src/higher-level/param-hl.c:  register_char_par(params,  "DIR_MODEL", _CHAR_TEST_EXIST_, &phl->mcl.d_model);
./src/higher-level/param-hl.c:  register_enum_par(params,  "ML_METHOD", _TAGGED_ENUM_ML_, _ML_LENGTH_, &phl->mcl.method);
./src/higher-level/param-hl.c:  register_float_par(params, "ML_CONVERGENCE", 0, INT_MAX, &phl->mcl.converge);
./src/higher-level/param-hl.c:  register_float_par(params, "ML_SCALE", 0, 1e6, &phl->mcl.scale);
./src/higher-level/param-hl.c:  register_char_par(params,  "ML_BASE",  _CHAR_TEST_NONE_, &phl->mcl.base);
./src/higher-level/param-hl.c:  register_bool_par(params,  "OUTPUT_MLP", &phl->mcl.omlp);
./src/higher-level/param-hl.c:  register_bool_par(params,  "OUTPUT_MLI", &phl->mcl.omli);
./src/higher-level/param-hl.c:  register_bool_par(params,  "OUTPUT_MLU", &phl->mcl.omlu);
./src/higher-level/param-hl.c:  register_bool_par(params,  "OUTPUT_RFP", &phl->mcl.orfp);
./src/higher-level/param-hl.c:  register_bool_par(params,  "OUTPUT_RFM", &phl->mcl.orfm);
./src/higher-level/param-hl.c:  for (i=0; i<phl->mcl.nmodelset; i++) register_charvec_par(params,  "FILE_MODEL",
./src/higher-level/param-hl.c:    _CHAR_TEST_BASE_, &phl->mcl.f_model[i], &phl->mcl.nmodel[i]);
./src/higher-level/param-hl.c:  for (i=0; i<phl->ftr.ntags; i++) register_charvec_par(params,  "INPUT_FEATURE",
./src/higher-level/param-hl.c:    _CHAR_TEST_NONE_, &phl->ftr.cfeature[i], &phl->ftr.ifeature[i]);
./src/higher-level/param-hl.c:  register_int_par(params,  "FEATURE_NODATA", SHRT_MIN, SHRT_MAX, &phl->ftr.nodata);
./src/higher-level/param-hl.c:  register_bool_par(params, "FEATURE_EXCLUDE", &phl->ftr.exclude);
./src/higher-level/param-hl.c:  register_char_par(params, "FILE_POINTS",      _CHAR_TEST_EXIST_,     &phl->smp.f_coord);
./src/higher-level/param-hl.c:  register_char_par(params, "FILE_SAMPLE",      _CHAR_TEST_NOT_EXIST_, &phl->smp.f_sample);
./src/higher-level/param-hl.c:  register_char_par(params, "FILE_RESPONSE",    _CHAR_TEST_NOT_EXIST_, &phl->smp.f_response);
./src/higher-level/param-hl.c:  register_char_par(params, "FILE_COORDINATES", _CHAR_TEST_NOT_EXIST_, &phl->smp.f_coords);
./src/higher-level/param-hl.c:  register_bool_par(params, "PROJECTED",        &phl->smp.projected);
./src/higher-level/param-hl.c:  register_double_par(params,  "TXT_RADIUS",    0, 1e6,  &phl->txt.radius);
./src/higher-level/param-hl.c:  register_int_par(params,     "TXT_ITERATION", 1, 1000, &phl->txt.iter);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "TXT", _TAGGED_ENUM_TXT_, _TXT_LENGTH_, &phl->txt.metrics, &phl->txt.nmetrics);
./src/higher-level/param-hl.c:  register_char_par(params,    "TXT_BASE",  _CHAR_TEST_NONE_, &phl->txt.base);
./src/higher-level/param-hl.c:  register_double_par(params,  "LSM_RADIUS",    0, 1e6,  &phl->lsm.radius);
./src/higher-level/param-hl.c:  register_int_par(params,     "LSM_MIN_PATCHSIZE",    0, 1e6,  &phl->lsm.minpatchsize);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "LSM_THRESHOLD_TYPE", _TAGGED_ENUM_QUERY_, _QUERY_LENGTH_, &phl->lsm.query, &phl->lsm.nquery);
./src/higher-level/param-hl.c:  register_intvec_par(params,  "LSM_THRESHOLD", SHRT_MIN, SHRT_MAX, &phl->lsm.threshold, &phl->lsm.nthreshold);
./src/higher-level/param-hl.c:  register_bool_par(params,    "LSM_ALL_PIXELS", &phl->lsm.allpx);
./src/higher-level/param-hl.c:  register_enumvec_par(params, "LSM", _TAGGED_ENUM_LSM_, _LSM_LENGTH_, &phl->lsm.metrics, &phl->lsm.nmetrics);
./src/higher-level/param-hl.c:  register_char_par(params,    "LSM_BASE",  _CHAR_TEST_NONE_, &phl->lsm.base);
./src/higher-level/param-hl.c:  register_enum_par(params,    "LSM_KERNEL_SHAPE", _TAGGED_ENUM_KERNEL_, _KERNEL_LENGTH_, &phl->lsm.kernel);
./src/higher-level/param-hl.c:  register_char_par(params,    "DIR_LIBRARY",  _CHAR_TEST_EXIST_, &phl->lib.d_lib);
./src/higher-level/param-hl.c:  register_charvec_par(params, "FILE_LIBRARY", _CHAR_TEST_BASE_,  &phl->lib.f_lib, &phl->lib.n_lib);
./src/higher-level/param-hl.c:  register_bool_par(params,    "LIB_RESCALE",  &phl->lib.rescale);
./src/higher-level/param-hl.c:  register_char_par(params,    "LIB_BASE",     _CHAR_TEST_NONE_,  &phl->lib.base);
./src/higher-level/param-hl.c:  register_char_par(params,    "FILE_PYTHON",  _CHAR_TEST_NULL_OR_EXIST_, &phl->udf.pyp.f_code);
./src/higher-level/param-hl.c:  register_enum_par(params,    "PYTHON_TYPE",  _TAGGED_ENUM_UDF_, _UDF_LENGTH_, &phl->udf.pyp.type);
./src/higher-level/param-hl.c:  register_bool_par(params,    "OUTPUT_PYP",    &phl->udf.pyp.out);
./src/higher-level/param-hl.c:  //register_char_par(params,    "FILE_RSTATS",  _CHAR_TEST_NULL_OR_EXIST_, &phl->udf.rsp.f_code);
./src/higher-level/param-hl.c:  //register_enum_par(params,    "RSTATS_TYPE",  _TAGGED_ENUM_UDF_, _UDF_LENGTH_, &phl->udf.rsp.type);
./src/higher-level/param-hl.c:  //register_bool_par(params,    "OUTPUT_RSP",   &phl->udf.rsp.out);
./src/higher-level/param-hl.c:  free_params(phl->params);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_QAI_ ||
./src/higher-level/param-hl.c:      phl->input_level1 == _INP_ARD_){
./src/higher-level/param-hl.c:    free_2D((void**)phl->sen.sensor, phl->sen.n);
./src/higher-level/param-hl.c:    free_2D((void**)phl->sen.band,   phl->sen.n);
./src/higher-level/param-hl.c:    free_2D((void**)phl->sen.domain, phl->sen.nb);
./src/higher-level/param-hl.c:  if (phl->input_level2 == _INP_QAI_ ||
./src/higher-level/param-hl.c:      phl->input_level2 == _INP_ARD_){
./src/higher-level/param-hl.c:    free_2D((void**)phl->sen2.sensor, phl->sen2.n);
./src/higher-level/param-hl.c:    free_2D((void**)phl->sen2.band,   phl->sen2.n);
./src/higher-level/param-hl.c:    free_2D((void**)phl->sen2.domain, phl->sen2.nb);
./src/higher-level/param-hl.c:  if (phl->type == _HL_TSA_) free_2D((void**)phl->tsa.index_name, phl->tsa.n); 
./src/higher-level/param-hl.c:  if (phl->type == _HL_ML_) free_mcl(&phl->mcl);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_FTR_) free_ftr(&phl->ftr);
./src/higher-level/param-hl.c:  phl->params = allocate_params();
./src/higher-level/param-hl.c:  if ((fpar = fopen(phl->f_par, "r")) == NULL){
./src/higher-level/param-hl.c:    phl->type = _HL_BAP_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_ARD_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_TSA_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_ARD_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_CSO_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_QAI_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_CFI_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_ARD_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_CON_;
./src/higher-level/param-hl.c:    phl->type = _HL_L2I_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_ARD_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_ARD_;
./src/higher-level/param-hl.c:    phl->type = _HL_ML_;
./src/higher-level/param-hl.c:    phl->input_level1  = _INP_FTR_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_SMP_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_FTR_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_TXT_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_FTR_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_LSM_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_FTR_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_LIB_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_FTR_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:    phl->type = _HL_UDF_;
./src/higher-level/param-hl.c:    phl->input_level1 = _INP_ARD_;
./src/higher-level/param-hl.c:    phl->input_level2 = _INP_NONE_;
./src/higher-level/param-hl.c:   register_higher(phl->params, phl);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_QAI_ ||
./src/higher-level/param-hl.c:      phl->input_level1 == _INP_ARD_){
./src/higher-level/param-hl.c:     register_ard1(phl->params, phl);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_ARD_){
./src/higher-level/param-hl.c:     register_ard2(phl->params, phl);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_FTR_){
./src/higher-level/param-hl.c:    if (prescreen_par(fpar, "INPUT_FEATURE", &phl->ftr.ntags) == FAILURE) return FAILURE;
./src/higher-level/param-hl.c:    alloc_ftr(&phl->ftr);
./src/higher-level/param-hl.c:    register_ftr(phl->params, phl);
./src/higher-level/param-hl.c:  switch (phl->type){
./src/higher-level/param-hl.c:      register_bap(phl->params, phl);
./src/higher-level/param-hl.c:      register_tsa(phl->params, phl);
./src/higher-level/param-hl.c:      register_cso(phl->params, phl);
./src/higher-level/param-hl.c:      register_cfi(phl->params, phl);
./src/higher-level/param-hl.c:      register_l2i(phl->params, phl);
./src/higher-level/param-hl.c:      if (prescreen_par(fpar, "FILE_MODEL", &phl->mcl.nmodelset) == FAILURE) return FAILURE;
./src/higher-level/param-hl.c:      alloc_mcl(&phl->mcl);
./src/higher-level/param-hl.c:      register_mcl(phl->params, phl);
./src/higher-level/param-hl.c:      register_smp(phl->params, phl);
./src/higher-level/param-hl.c:      register_txt(phl->params, phl);
./src/higher-level/param-hl.c:      register_lsm(phl->params, phl);
./src/higher-level/param-hl.c:      register_lib(phl->params, phl);
./src/higher-level/param-hl.c:      register_udf(phl->params, phl);
./src/higher-level/param-hl.c:  while (fgets(buffer, NPOW_16, fpar) != NULL) parse_parameter(phl->params, buffer);
./src/higher-level/param-hl.c:  print_parameter(phl->params);
./src/higher-level/param-hl.c:  if (check_parameter(phl->params) == FAILURE) return FAILURE;
./src/higher-level/param-hl.c:  log_parameter(phl->params);
./src/higher-level/param-hl.c:  if ((phl->input_level1 == _INP_QAI_ ||
./src/higher-level/param-hl.c:       phl->input_level1 == _INP_ARD_) &&
./src/higher-level/param-hl.c:    parse_sensor(&phl->sen) != SUCCESS){
./src/higher-level/param-hl.c:  if ((phl->input_level2 == _INP_QAI_ ||
./src/higher-level/param-hl.c:       phl->input_level2 == _INP_ARD_) &&
./src/higher-level/param-hl.c:    parse_sensor(&phl->sen2) != SUCCESS){
./src/higher-level/param-hl.c:  if (phl->type == _HL_TSA_ && check_bandlist(&phl->tsa, &phl->sen) == FAILURE){
./src/higher-level/param-hl.c:  if (phl->type == _HL_TSA_) parse_sta(&phl->tsa.stm.sta);
./src/higher-level/param-hl.c:  if (phl->type == _HL_CSO_) parse_sta(&phl->cso.sta);
./src/higher-level/param-hl.c:  if (phl->type == _HL_TSA_) parse_lsp(&phl->tsa.lsp);
./src/higher-level/param-hl.c:  if (phl->type == _HL_TSA_) parse_pol(&phl->tsa.pol);
./src/higher-level/param-hl.c:  if (phl->type == _HL_TXT_) parse_txt(&phl->txt);
./src/higher-level/param-hl.c:  if (phl->type == _HL_LSM_) parse_lsm(&phl->lsm);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_FTR_) parse_ftr(&phl->ftr);
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_ARD_ ||
./src/higher-level/param-hl.c:      phl->input_level1 == _INP_QAI_) parse_quality(&phl->qai);
./src/higher-level/param-hl.c:  if (phl->input_level1 != _INP_QAI_) phl->prd.ref = true;
./src/higher-level/param-hl.c:  phl->prd.qai = true;
./src/higher-level/param-hl.c:  if ((phl->input_level1 == _INP_QAI_ ||
./src/higher-level/param-hl.c:       phl->input_level1 == _INP_ARD_) &&
./src/higher-level/param-hl.c:       phl->doy_range[_MIN_] > 0 && 
./src/higher-level/param-hl.c:       phl->doy_range[_MAX_] > 0){
./src/higher-level/param-hl.c:    if (phl->doy_range[_MIN_] < phl->doy_range[_MAX_]){
./src/higher-level/param-hl.c:      for (d=phl->doy_range[_MIN_]; d<=phl->doy_range[_MAX_]; d++) phl->date_doys[d] = true;
./src/higher-level/param-hl.c:      for (d=1; d<=phl->doy_range[_MAX_];   d++) phl->date_doys[d] = true;
./src/higher-level/param-hl.c:      for (d=phl->doy_range[_MIN_]; d<=365; d++) phl->date_doys[d] = true;
./src/higher-level/param-hl.c:      if (!phl->date_doys[d]) continue;
./src/higher-level/param-hl.c:      w = doy2week(d);    phl->date_weeks[w] = true;
./src/higher-level/param-hl.c:      m = doy2m(d);       phl->date_months[m] = true;
./src/higher-level/param-hl.c:      q = doy2quarter(d); phl->date_quarters[q] = true;
./src/higher-level/param-hl.c:    for (d=1; d<=365; d++) phl->nd += phl->date_doys[d];
./src/higher-level/param-hl.c:    for (w=1; w<=52;  w++) phl->nw += phl->date_weeks[w];
./src/higher-level/param-hl.c:    for (m=1; m<=12;  m++) phl->nm += phl->date_months[m];
./src/higher-level/param-hl.c:    for (q=1; q<=4;   q++) phl->nq += phl->date_quarters[q];
./src/higher-level/param-hl.c:    phl->ny = phl->date_range[_MAX_].year - phl->date_range[_MIN_].year + 1;
./src/higher-level/param-hl.c:    phl->tsa.lsp.ny = phl->ny-2;
./src/higher-level/param-hl.c:    phl->tsa.pol.ny = phl->ny;
./src/higher-level/param-hl.c:    phl->tsa.pol.ns = phl->ny-1;
./src/higher-level/param-hl.c:      phl->ny, phl->nq, phl->nm, phl->nw, phl->nd);
./src/higher-level/param-hl.c:    for (d=1; d<=365; d++) printf("temporal filter day %d: %d\n", d, phl->date_doys[d]);
./src/higher-level/param-hl.c:    for (w=1; w<=52;  w++) printf("temporal filter week %d: %d\n", w, phl->date_weeks[w]);
./src/higher-level/param-hl.c:    for (m=1; m<=12;  m++) printf("temporal filter month %d: %d\n", m, phl->date_months[m]);
./src/higher-level/param-hl.c:    for (q=1; q<=4;   q++) printf("temporal filter quarter %d: %d\n", q, phl->date_quarters[q]);
./src/higher-level/param-hl.c:    printf("day: %03d - %03d\n", phl->doy_range[_MIN_], phl->doy_range[_MAX_]);
./src/higher-level/param-hl.c:  if (phl->type == _HL_TXT_){
./src/higher-level/param-hl.c:    phl->radius = phl->txt.radius*phl->txt.iter;
./src/higher-level/param-hl.c:    phl->txt.radius = (int)(phl->txt.radius/phl->res);
./src/higher-level/param-hl.c:  } else if (phl->type == _HL_LSM_){
./src/higher-level/param-hl.c:    phl->radius = phl->lsm.radius;
./src/higher-level/param-hl.c:    phl->lsm.radius = (int)(phl->lsm.radius/phl->res);
./src/higher-level/param-hl.c:  } else if (phl->type == _HL_L2I_ || phl->type == _HL_CFI_){
./src/higher-level/param-hl.c:    if (phl->imp.pred_radius > phl->imp.text_radius){
./src/higher-level/param-hl.c:      phl->radius = phl->imp.pred_radius;
./src/higher-level/param-hl.c:      phl->radius = phl->imp.text_radius;
./src/higher-level/param-hl.c:    phl->imp.ksize = (int)(phl->imp.pred_radius/phl->res);
./src/higher-level/param-hl.c:    phl->imp.ksd   = (int)(phl->imp.text_radius/phl->res);
./src/higher-level/param-hl.c:    phl->radius = 0;
./src/higher-level/param-hl.c:  if (phl->radius != 0 && fmod(phl->radius, phl->res) > tol){
./src/higher-level/param-hl.c:    printf("requested RADIUS %f must be a multiple of RESOLUTION %f\n", phl->radius, phl->res);
./src/higher-level/param-hl.c:  if (phl->type == _HL_L2I_ || phl->type == _HL_CFI_){
./src/higher-level/param-hl.c:    if ((phl->imp.nwin = phl->imp.bwin-1) <= 0){
./src/higher-level/param-hl.c:  if (phl->type == _HL_BAP_){
./src/higher-level/param-hl.c:    phl->bap.w.t = phl->bap.w.d + phl->bap.w.y + phl->bap.w.c  + phl->bap.w.h +
./src/higher-level/param-hl.c:             phl->bap.w.r + phl->bap.w.v;
./src/higher-level/param-hl.c:    if (phl->bap.w.t == 0){
./src/higher-level/param-hl.c:    phl->bap.Yn = (phl->bap.Yr*2)+1;
./src/higher-level/param-hl.c:    if (phl->bap.Ds[1] > phl->bap.Ds[0] &&
./src/higher-level/param-hl.c:        phl->bap.Ds[1] > phl->bap.Ds[2]){
./src/higher-level/param-hl.c:      phl->bap.score_type = _SCR_TYPE_GAUSS_; // gaussian
./src/higher-level/param-hl.c:    } else if (phl->bap.Ds[0] > phl->bap.Ds[2]){
./src/higher-level/param-hl.c:      phl->bap.score_type = _SCR_TYPE_SIG_DES_; // descending sigmoid
./src/higher-level/param-hl.c:    } else if (phl->bap.Ds[2] > phl->bap.Ds[0]){
./src/higher-level/param-hl.c:      phl->bap.score_type = _SCR_TYPE_SIG_ASC_; // ascending sigmoid
./src/higher-level/param-hl.c:    if (phl->bap.w.c > 0) phl->prd.dst = true;
./src/higher-level/param-hl.c:    if (phl->bap.w.h > 0) phl->prd.hot = true;
./src/higher-level/param-hl.c:    if (phl->bap.w.v > 0) phl->prd.vzn = true;
./src/higher-level/param-hl.c:    if (phl->bap.pac.lsp) phl->input_level2 = _INP_CON_;
./src/higher-level/param-hl.c:  if (phl->ntx != 2){
./src/higher-level/param-hl.c:  if (phl->nty != 2){
./src/higher-level/param-hl.c:  if (phl->tx[_MIN_] > phl->tx[_MAX_]){
./src/higher-level/param-hl.c:    tmp = phl->tx[_MIN_]; phl->tx[_MIN_] = phl->tx[_MAX_]; phl->tx[_MAX_] = tmp;}
./src/higher-level/param-hl.c:  if (phl->ty[_MIN_] > phl->ty[_MAX_]){
./src/higher-level/param-hl.c:    tmp = phl->ty[_MIN_]; phl->ty[_MIN_] = phl->ty[_MAX_]; phl->ty[_MAX_] = tmp;}
./src/higher-level/param-hl.c:  if (strcmp(phl->d_mask, "NULL") != 0 && strcmp(phl->b_mask, "NULL") == 0){
./src/higher-level/param-hl.c:  if (phl->input_level1 == _INP_QAI_ ||
./src/higher-level/param-hl.c:      phl->input_level1 == _INP_ARD_){
./src/higher-level/param-hl.c:    if (phl->ndate != 2){
./src/higher-level/param-hl.c:    if (phl->ndoy != 2){
./src/higher-level/param-hl.c:  if (phl->type == _HL_LSM_){
./src/higher-level/param-hl.c:    if (phl->lsm.nthreshold != phl->ftr.nfeature){
./src/higher-level/param-hl.c:    if (phl->lsm.nquery != phl->ftr.nfeature){
./src/higher-level/param-hl.c:  if (phl->type == _HL_TSA_){
./src/higher-level/param-hl.c:    if (phl->tsa.sma.orms && !phl->tsa.sma.v){
./src/higher-level/param-hl.c:      phl->tsa.sma.orms = false;
./src/higher-level/param-hl.c:    if (phl->tsa.sma.v && !phl->tsa.sma.pos && !phl->tsa.sma.sto){
./src/higher-level/param-hl.c:    if ((strcmp(phl->tsa.sma.f_emb, "NULL") == 0) && phl->tsa.sma.v){
./src/higher-level/param-hl.c:    if (phl->tsa.lsp.ospl || phl->tsa.lsp.olsp || phl->tsa.lsp.otrd || phl->tsa.lsp.ocat){
./src/higher-level/param-hl.c:      if (phl->tsa.lsp.ny < 1){
./src/higher-level/param-hl.c:      if (phl->tsa.tsi.method == _INT_NONE_){
./src/higher-level/param-hl.c:      if (phl->tsa.lsp.hemi == _HEMI_NORTH_ || phl->tsa.lsp.hemi == _HEMI_MIXED_){
./src/higher-level/param-hl.c:        if (phl->tsa.lsp.dnext < phl->tsa.tsi.step){
./src/higher-level/param-hl.c:      if (phl->tsa.lsp.hemi == _HEMI_NORTH_){
./src/higher-level/param-hl.c:        if (phl->tsa.lsp.dprev > 365-phl->tsa.tsi.step){
./src/higher-level/param-hl.c:      if (phl->tsa.lsp.hemi == _HEMI_SOUTH_ || phl->tsa.lsp.hemi == _HEMI_MIXED_){
./src/higher-level/param-hl.c:        if (phl->tsa.lsp.dprev > 182-phl->tsa.tsi.step){
./src/higher-level/param-hl.c:    if (phl->tsa.pol.opct || phl->tsa.pol.opol || phl->tsa.pol.otrd || phl->tsa.pol.ocat){
./src/higher-level/param-hl.c:      if (phl->tsa.pol.ns < 1){
./src/higher-level/param-hl.c:      if (phl->tsa.tsi.method == _INT_NONE_){
./src/higher-level/param-hl.c:    if (phl->tsa.pyp.out && strcmp(phl->tsa.pyp.f_code, "NULL") == 0){
./src/higher-level/param-hl.c:      phl->tsa.pyp.out = false;
./src/higher-level/param-hl.c:    if (!phl->tsa.pyp.out && strcmp(phl->tsa.pyp.f_code, "NULL") != 0){
./src/higher-level/param-hl.c:      copy_string(phl->tsa.pyp.f_code, NPOW_10, "NULL");
./src/higher-level/param-hl.c:  if (phl->type == _HL_UDF_){
./src/higher-level/param-hl.c:    if (phl->udf.pyp.out && strcmp(phl->udf.pyp.f_code, "NULL") == 0){
./src/higher-level/param-hl.c:      phl->udf.pyp.out = false;
./src/higher-level/param-hl.c:    if (!phl->udf.pyp.out && strcmp(phl->udf.pyp.f_code, "NULL") != 0){
./src/higher-level/param-hl.c:      copy_string(phl->udf.pyp.f_code, NPOW_10, "NULL");
./src/higher-level/param-hl.c:    if (phl->udf.rsp.out && strcmp(phl->udf.rsp.f_code, "NULL") == 0){
./src/higher-level/param-hl.c:      phl->udf.rsp.out = false;
./src/higher-level/param-hl.c:    if (!phl->udf.rsp.out && strcmp(phl->udf.rsp.f_code, "NULL") != 0){
./src/higher-level/param-hl.c:      copy_string(phl->udf.rsp.f_code, NPOW_10, "NULL");
./src/higher-level/param-hl.c:  if (phl->type == _HL_CFI_){
./src/higher-level/param-hl.c:    for (y=0; y<phl->cfi.nyears; y++){
./src/higher-level/param-hl.c:      if (phl->cfi.years[y] < phl->date_range[_MIN_].year || 
./src/higher-level/param-hl.c:          phl->cfi.years[y] > phl->date_range[_MAX_].year){
./src/higher-level/param-hl.c:        printf("The prediction year %d (COARSE_PREDICT_YEARS) is outside of DATE_RANGE. This won't work.\n", phl->cfi.years[y]); return FAILURE;}
./src/higher-level/param-hl.c:  if (phl->type == _HL_ML_){
./src/higher-level/param-hl.c:    if (phl->mcl.orfp && phl->mcl.method != _ML_RFC_){
./src/higher-level/param-hl.c:      phl->mcl.orfp = false;
./src/higher-level/param-hl.c:    if (phl->mcl.orfm && phl->mcl.method != _ML_RFC_){
./src/higher-level/param-hl.c:      phl->mcl.orfm = false;
./src/higher-level/param-hl.c:  if (phl->format == _FMT_CUSTOM_){
./src/higher-level/param-hl.c:    if (strcmp(phl->f_gdalopt, "NULL") == 0 || !fileexist(phl->f_gdalopt)){
./src/higher-level/spec-adjust-hl.c:  if (!phl->sen.spec_adjust) return CANCEL;
./src/higher-level/pheno-hl.cpp:  if (phl->tsa.lsp.ospl +
./src/higher-level/pheno-hl.cpp:      phl->tsa.lsp.olsp +
./src/higher-level/pheno-hl.cpp:      phl->tsa.lsp.otrd +
./src/higher-level/pheno-hl.cpp:      phl->tsa.lsp.ocat == 0) return SUCCESS;
./src/higher-level/pheno-hl.cpp:  //    phl->date_range[_MIN_].year, phl->date_range[_MAX_].year, &phl->tsa.lsp) == FAILURE) return FAILURE;
./src/higher-level/pheno-hl.cpp:    for (y=0; y<phl->tsa.lsp.ny; y++){
./src/higher-level/pheno-hl.cpp:        y, phl->date_range[_MIN_].year, &phl->tsa.lsp) == FAILURE) return FAILURE;
./src/higher-level/level3-hl.c:bool explode[4] = { false, phl->explode, phl->explode, false };
./src/higher-level/level3-hl.c:bool enable[4] = { phl->bap.obap, phl->bap.oinf, phl->bap.oscr, phl->bap.oovv };
./src/higher-level/level3-hl.c:  if (phl->bap.score_type == _SCR_TYPE_SIG_DES_) doy2md(phl->bap.Dt[0], &m, &d);
./src/higher-level/level3-hl.c:  if (phl->bap.score_type == _SCR_TYPE_GAUSS_)   doy2md(phl->bap.Dt[1], &m, &d);
./src/higher-level/level3-hl.c:  if (phl->bap.score_type == _SCR_TYPE_SIG_ASC_) doy2md(phl->bap.Dt[2], &m, &d);
./src/higher-level/level3-hl.c:  date.year = phl->bap.Yt;
./src/higher-level/level3-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/level3-hl.c:    date.year, date.month, date.day, phl->sen.target, prodname);
./src/higher-level/level3-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/level3-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/level3-hl.c:  if (phl->bap.pac.lsp && lsp == NULL){
./src/higher-level/level3-hl.c:  if (phl->bap.pac.lsp) lsp_nodata = get_brick_nodata(lsp[0].DAT, 0);
./src/higher-level/level3-hl.c:  if (phl->bap.pac.lsp && nlsp > 3){
./src/higher-level/level3-hl.c:  } else if (phl->bap.pac.lsp && nlsp < 3){
./src/higher-level/level3-hl.c:    if (phl->bap.w.r > 0) alloc_2D((void***)&cor, nt, nt, sizeof(float));
./src/higher-level/level3-hl.c:    if (!phl->bap.pac.lsp) target = compile_target_static(&phl->bap);
./src/higher-level/level3-hl.c:      if (phl->bap.pac.lsp) target = compile_target_adaptive(&phl->bap, lsp, p, lsp_nodata);
./src/higher-level/level3-hl.c:      if (phl->bap.w.r > 0) corr_matrix(ard, nt, nb, p, cor);
./src/higher-level/level3-hl.c:      parametric_score(ard, nt, p, target, cor, score, tdist, &phl->bap);
./src/higher-level/level3-hl.c:      haze_stats(ard, nt, p, score, &phl->bap, &hmean, &hsd);
./src/higher-level/level3-hl.c:      bap_compositing(ard, &l3, nt, nb, nodata, p, score, tdist, hmean, hsd, water, &phl->bap);
./src/higher-level/level3-hl.c:      if (phl->bap.pac.lsp) free((void*)target);
./src/higher-level/level3-hl.c:    if (!phl->bap.pac.lsp) free((void*)target);
./src/higher-level/level3-hl.c:    if (phl->bap.w.r > 0) free_2D((void**)cor, nt);
./src/higher-level/read-ard-hl.c:  nchar = snprintf(d.name, NPOW_10, "%s/X%04d_Y%04d", phl->d_mask, tx, ty);
./src/higher-level/read-ard-hl.c:    if (strcmp(d.LIST[m]->d_name, phl->b_mask) == 0){
./src/higher-level/read-ard-hl.c:  nchar = snprintf(d.name, NPOW_10, "%s/X%04d_Y%04d", phl->d_lower, tx, ty);
./src/higher-level/read-ard-hl.c:      if (date.ce < phl->date_range[_MIN_].ce) vs = false;
./src/higher-level/read-ard-hl.c:      if (date.ce > phl->date_range[_MAX_].ce) vs = false;
./src/higher-level/read-ard-hl.c:      if (!phl->date_doys[date.doy])  vs = false;
./src/higher-level/read-ard-hl.c:  if (strcmp(phl->d_mask, "NULL") == 0){
./src/higher-level/read-ard-hl.c:  if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:    if ((MASK = add_blocks(fname, _ARD_MSK_, NULL, 1, 1, 255, _DT_SMALL_, chunk, tx, ty, cube, false, phl->radius, MASK)) == NULL){
./src/higher-level/read-ard-hl.c:  for (f=0; f<phl->ftr.nfeature; f++){
./src/higher-level/read-ard-hl.c:    nchar = snprintf(fname, NPOW_10, "%s/X%04d_Y%04d/%s", phl->d_lower, tx, ty, phl->ftr.bname[f]);
./src/higher-level/read-ard-hl.c:  alloc((void**)&features, phl->ftr.nfeature, sizeof(ard_t));
./src/higher-level/read-ard-hl.c:    for (f=0; f<phl->ftr.nfeature; f++){
./src/higher-level/read-ard-hl.c:      nchar = snprintf(fname, NPOW_10, "%s/X%04d_Y%04d/%s", phl->d_lower, tx, ty, phl->ftr.bname[f]);
./src/higher-level/read-ard-hl.c:      if ((features[f].DAT = read_block(fname, _ARD_FTR_, NULL, phl->ftr.band[f], 1, phl->ftr.nodata, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:        if ((features[f].DAT = add_blocks(fname, _ARD_FTR_, NULL, phl->ftr.band[f], 1, phl->ftr.nodata, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, features[f].DAT)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (features[f].dat[0][p] == phl->ftr.nodata) set_off(features[f].QAI, p, true);
./src/higher-level/read-ard-hl.c:    free_ard(features, phl->ftr.nfeature);
./src/higher-level/read-ard-hl.c:  *nt = phl->ftr.nfeature;
./src/higher-level/read-ard-hl.c:  for (f=0; f<phl->con.n; f++){
./src/higher-level/read-ard-hl.c:    nchar = snprintf(fname, NPOW_10, "%s/X%04d_Y%04d/%s", phl->con.dname, tx, ty, phl->con.fname[f]);
./src/higher-level/read-ard-hl.c:  alloc((void**)&con, phl->con.n, sizeof(ard_t));
./src/higher-level/read-ard-hl.c:    for (f=0; f<phl->con.n; f++){
./src/higher-level/read-ard-hl.c:      nchar = snprintf(fname, NPOW_10, "%s/X%04d_Y%04d/%s", phl->con.dname, tx, ty, phl->con.fname[f]);
./src/higher-level/read-ard-hl.c:      if ((con[f].DAT = read_block(fname, _ARD_FTR_, NULL, 1, -1, phl->con.nodata, _DT_SHORT_, chunk, tx, ty, cube, false, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:        if ((con[f].DAT = add_blocks(fname, _ARD_FTR_, NULL, 1, -1, phl->con.nodata, _DT_SHORT_, chunk, tx, ty, cube, false, phl->radius, con[f].DAT)) == NULL ||
./src/higher-level/read-ard-hl.c:    free_ard(con, phl->con.n);
./src/higher-level/read-ard-hl.c:  *nt = phl->con.n;
./src/higher-level/read-ard-hl.c:      if (phl->prd.imp){
./src/higher-level/read-ard-hl.c:      if (phl->prd.ref){
./src/higher-level/read-ard-hl.c:        if ((ard[t].DAT = read_block(fname, _ARD_REF_, sen, 0, 0, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:          if ((ard[t].DAT = add_blocks(fname, _ARD_REF_, sen, 0, 0, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, ard[t].DAT)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->prd.qai){
./src/higher-level/read-ard-hl.c:          if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:            if ((ard[t].QAI = add_blocks(fname, _ARD_AUX_, sen, 1, 1, 1, _DT_SHORT_, chunk, tx, ty, cube, false, phl->radius, ard[t].QAI)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->prd.dst){
./src/higher-level/read-ard-hl.c:        if ((ard[t].DST = read_block(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:          if ((ard[t].DST = add_blocks(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, ard[t].DST)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->prd.aod){
./src/higher-level/read-ard-hl.c:        if ((ard[t].AOD = read_block(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:          if ((ard[t].AOD = add_blocks(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, ard[t].AOD)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->prd.hot){
./src/higher-level/read-ard-hl.c:        if ((ard[t].HOT = read_block(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:          if ((ard[t].HOT = add_blocks(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, ard[t].HOT)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->prd.vzn){
./src/higher-level/read-ard-hl.c:        if ((ard[t].VZN = read_block(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:          if ((ard[t].VZN = add_blocks(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, ard[t].VZN)) == NULL ||
./src/higher-level/read-ard-hl.c:      if (phl->prd.wvp){
./src/higher-level/read-ard-hl.c:        if ((ard[t].WVP = read_block(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, 0, 0)) == NULL ||
./src/higher-level/read-ard-hl.c:        if (phl->radius > 0){
./src/higher-level/read-ard-hl.c:          if ((ard[t].WVP = add_blocks(fname, _ARD_AUX_, sen, 1, 1, -9999, _DT_SHORT_, chunk, tx, ty, cube, phl->psf, phl->radius, ard[t].WVP)) == NULL ||
./src/higher-level/py-udf-hl.c:  if (phl->tsa.pyp.out){
./src/higher-level/py-udf-hl.c:    udf = &phl->tsa.pyp;
./src/higher-level/py-udf-hl.c:  } else if (phl->udf.pyp.out){
./src/higher-level/py-udf-hl.c:    udf = &phl->udf.pyp;
./src/higher-level/py-udf-hl.c:  if (phl->tsa.pyp.out){
./src/higher-level/py-udf-hl.c:    udf = &phl->tsa.pyp;
./src/higher-level/py-udf-hl.c:  } else if (phl->udf.pyp.out){
./src/higher-level/py-udf-hl.c:    udf = &phl->udf.pyp;
./src/higher-level/standardize-hl.c:  if (phl->tsa.otss)     standardize_timeseries(ts->tss_, mask_, nc, nt,      nodata, phl->tsa.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.tsi.otsi) standardize_timeseries(ts->tsi_, mask_, nc, ni,      nodata, phl->tsa.tsi.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.fld.ofby) standardize_timeseries(ts->fby_, mask_, nc, phl->ny, nodata, phl->tsa.fld.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.fld.ofbq) standardize_timeseries(ts->fbq_, mask_, nc, phl->nq, nodata, phl->tsa.fld.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.fld.ofbm) standardize_timeseries(ts->fbm_, mask_, nc, phl->nm, nodata, phl->tsa.fld.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.fld.ofbw) standardize_timeseries(ts->fbw_, mask_, nc, phl->nw, nodata, phl->tsa.fld.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.fld.ofbd) standardize_timeseries(ts->fbd_, mask_, nc, phl->nd, nodata, phl->tsa.fld.standard);
./src/higher-level/standardize-hl.c:  if (phl->tsa.lsp.ocat){
./src/higher-level/standardize-hl.c:      standardize_timeseries(ts->lsp_[l], mask_, nc, phl->tsa.lsp.ny, nodata, phl->tsa.lsp.standard);
./src/higher-level/ml-hl.c:int prodlen[2] = { phl->mcl.nmodelset, phl->mcl.nclass_all_sets };
./src/higher-level/ml-hl.c:bool enable[5] = { phl->mcl.omlp, phl->mcl.omli, phl->mcl.omlu, phl->mcl.orfp, phl->mcl.orfm };
./src/higher-level/ml-hl.c:bool write[5]  = { phl->mcl.omlp, phl->mcl.omli, phl->mcl.omlu, phl->mcl.orfp, phl->mcl.orfm };
./src/higher-level/ml-hl.c:            for (s=0; s<phl->mcl.nmodelset; s++){
./src/higher-level/ml-hl.c:              basename_without_ext(phl->mcl.f_model[s][0], bname, NPOW_10);
./src/higher-level/ml-hl.c:            for (s=0, sc=0; s<phl->mcl.nmodelset; s++){
./src/higher-level/ml-hl.c:              basename_without_ext(phl->mcl.f_model[s][0], bname, NPOW_10);
./src/higher-level/ml-hl.c:              for (c=0; c<phl->mcl.nclass[s]; c++, sc++){
./src/higher-level/ml-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/ml-hl.c:  nchar = snprintf(fname, NPOW_10, "%s_HL_ML_%s", phl->mcl.base, prodname);
./src/higher-level/ml-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/ml-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/ml-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/ml-hl.c:  if (phl->mcl.method == _ML_SVR_ || phl->mcl.method == _ML_RFR_) regression = true; else regression = false;
./src/higher-level/ml-hl.c:  if (phl->mcl.method == _ML_RFR_ || phl->mcl.method == _ML_RFC_) rf = true; else rf = false;
./src/higher-level/ml-hl.c:  if (phl->mcl.orfp || phl->mcl.orfm) rfprob = true; else rfprob = false;
./src/higher-level/ml-hl.c:    if (rfprob) alloc((void**)&mean_prob, phl->mcl.nclass_all_sets, sizeof(double));
./src/higher-level/ml-hl.c:        for (s=0, sc=0; s<phl->mcl.nmodelset; s++){
./src/higher-level/ml-hl.c:          for (c=0; c<phl->mcl.nclass[s]; c++, sc++){
./src/higher-level/ml-hl.c:        if (!features[f].msk[p] && phl->ftr.exclude) valid=false;
./src/higher-level/ml-hl.c:        for (s=0, sc=0; s<phl->mcl.nmodelset; s++){
./src/higher-level/ml-hl.c:          for (c=0; c<phl->mcl.nclass[s]; c++, sc++){
./src/higher-level/ml-hl.c:      for (s=0, k=0, sc=0; s<phl->mcl.nmodelset; s++){
./src/higher-level/ml-hl.c:        if (rfprob) memset(mean_prob, 0, phl->mcl.nclass_all_sets*sizeof(double));
./src/higher-level/ml-hl.c:        for (m=0; m<phl->mcl.nmodel[s]; m++, k++){
./src/higher-level/ml-hl.c:            for (c=0; c<phl->mcl.nclass[s]; c++){
./src/higher-level/ml-hl.c:            if (m > 1 && fabs(mean-mean_old) < phl->mcl.converge){ k += phl->mcl.nmodel[s]-m; m++; break;}
./src/higher-level/ml-hl.c:          mn  = mean*phl->mcl.scale;
./src/higher-level/ml-hl.c:          if (ml.mlp_ != NULL) ml.mlp_[s][p] = (short)mode(ipred[s], phl->mcl.nmodel[s]);
./src/higher-level/ml-hl.c:          for (c=0; c<phl->mcl.nclass[s]; c++) mean_prob[c] /= (ntree*0.0001);
./src/higher-level/ml-hl.c:            for (c=0; c<phl->mcl.nclass[s]; c++) ml.rfp_[sc++][p] = (short)mean_prob[c];
./src/higher-level/ml-hl.c:            for (c=0; c<phl->mcl.nclass[s]; c++){
./src/higher-level/ml-hl.c:            for (c=0; c<phl->mcl.nclass[s]; c++){
./src/higher-level/fold-hl.c:  if ((phl->tsa.fld.type >= _STA_Q01_ && phl->tsa.fld.type <= _STA_Q99_) ||
./src/higher-level/fold-hl.c:       phl->tsa.fld.type == _STA_IQR_) alloc_q_array = true;
./src/higher-level/fold-hl.c:          switch (phl->tsa.fld.type){
./src/higher-level/fold-hl.c:          if (phl->tsa.fld.type >= _STA_Q01_ && phl->tsa.fld.type <= _STA_Q99_){
./src/higher-level/fold-hl.c:            fld_[f][p] = (short)quantile(q_array, n, (phl->tsa.fld.type-_STA_Q01_+1)/100.0);
./src/higher-level/fold-hl.c:  fold(ts->tsi_, ts->d_tsi, mask_, nc, ni, ts->fby_, ts->d_fby, phl->ny, nodata, _YEAR_,    phl);
./src/higher-level/fold-hl.c:  fold(ts->tsi_, ts->d_tsi, mask_, nc, ni, ts->fbq_, ts->d_fbq, phl->nq, nodata, _QUARTER_, phl);
./src/higher-level/fold-hl.c:  fold(ts->tsi_, ts->d_tsi, mask_, nc, ni, ts->fbm_, ts->d_fbm, phl->nm, nodata, _MONTH_,   phl);
./src/higher-level/fold-hl.c:  fold(ts->tsi_, ts->d_tsi, mask_, nc, ni, ts->fbw_, ts->d_fbw, phl->nw, nodata, _WEEK_,    phl);
./src/higher-level/fold-hl.c:  fold(ts->tsi_, ts->d_tsi, mask_, nc, ni, ts->fbd_, ts->d_fbd, phl->nd, nodata, _DOY_,     phl);
./src/higher-level/read-aux-hl.c:  if ((aux->endmember.tab = read_table(phl->tsa.sma.f_emb, 
./src/higher-level/read-aux-hl.c:  phl->mcl.nclass_all_sets = 0;
./src/higher-level/read-aux-hl.c:  for (s=0; s<phl->mcl.nmodelset; s++){
./src/higher-level/read-aux-hl.c:    phl->mcl.nclass[s] = 0;
./src/higher-level/read-aux-hl.c:    for (m=0; m<phl->mcl.nmodel[s]; m++){
./src/higher-level/read-aux-hl.c:      nchar = snprintf(fname, NPOW_10, "%s/%s", phl->mcl.d_model, phl->mcl.f_model[s][m]);
./src/higher-level/read-aux-hl.c:      if (phl->mcl.method == _ML_SVR_ || 
./src/higher-level/read-aux-hl.c:          phl->mcl.method == _ML_SVC_){
./src/higher-level/read-aux-hl.c:      } else if (phl->mcl.method == _ML_RFR_ || 
./src/higher-level/read-aux-hl.c:                 phl->mcl.method == _ML_RFC_){
./src/higher-level/read-aux-hl.c:        if (phl->mcl.method == _ML_RFC_){
./src/higher-level/read-aux-hl.c:          cv::Mat sample(1, phl->ftr.nfeature, CV_32F);
./src/higher-level/read-aux-hl.c:          phl->mcl.nclass[s] = vote.cols;
./src/higher-level/read-aux-hl.c:    phl->mcl.nclass_all_sets += phl->mcl.nclass[s];
./src/higher-level/read-aux-hl.c:  aux->library.n = phl->lib.n_lib;
./src/higher-level/read-aux-hl.c:  for (i=0; i<phl->lib.n_lib; i++){
./src/higher-level/read-aux-hl.c:    nchar = snprintf(fname, NPOW_10, "%s/%s", phl->lib.d_lib, phl->lib.f_lib[i]);
./src/higher-level/read-aux-hl.c:    if (phl->lib.rescale){
./src/higher-level/read-aux-hl.c:  if (phl->lib.rescale) aux->library.scaled = true;
./src/higher-level/read-aux-hl.c:  if ((aux->sample.tab = read_table(phl->smp.f_coord, &ns, &nr)) == NULL){
./src/higher-level/read-aux-hl.c:  if (phl->type == _HL_TSA_ && phl->tsa.sma.v){
./src/higher-level/read-aux-hl.c:  if (phl->type == _HL_ML_){
./src/higher-level/read-aux-hl.c:  if (phl->type == _HL_LIB_){
./src/higher-level/read-aux-hl.c:  if (phl->type == _HL_SMP_){
./src/higher-level/read-aux-hl.c:    if (phl->type == _HL_TSA_ && phl->tsa.sma.v && aux->endmember.tab != NULL){
./src/higher-level/read-aux-hl.c:    if (phl->type == _HL_LIB_&& 
./src/higher-level/read-aux-hl.c:    if (phl->type == _HL_SMP_){
./src/higher-level/l2-improphe-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/l2-improphe-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/l2-improphe-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/l2-improphe-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/l2-improphe-hl.c:  if ((seasonal_avg_ = average_season(ard_hr, mask_, nb_hr, nc, nt_hr, nodata, phl->imp.nwin, phl->imp.dwin, -1, &is_empty)) == NULL){
./src/higher-level/l2-improphe-hl.c:  if ((hr_ = pca(seasonal_avg_, mask_, phl->imp.nwin*nb_hr, nc, nodata, 0.975, &npc)) == NULL){
./src/higher-level/l2-improphe-hl.c:  free_2D((void**)seasonal_avg_, phl->imp.nwin*nb_hr);
./src/higher-level/l2-improphe-hl.c:  if ((hr_tex_ = focal_sd(hr_, nodata, phl->imp.ksd, nx, ny, npc, 0)) == NULL){
./src/higher-level/l2-improphe-hl.c:  width = phl->imp.ksize*2+1;
./src/higher-level/l2-improphe-hl.c:  printf("radius/width/nkernel/minnum: %d/%d/%d/%d\n", phl->imp.ksize, width, nk, mink);
./src/higher-level/l2-improphe-hl.c:      if ((mr_tex_[b] = focal_sd(mr_, nodata, phl->imp.ksd, nx, ny, 1, b)) == NULL){
./src/higher-level/l2-improphe-hl.c:          nx, ny, phl->imp.ksize, npc, nb_mr, nk, mink);
./src/higher-level/lsm-hl.c:int prodlen[11] ={ phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature, phl->ftr.nfeature };
./src/higher-level/lsm-hl.c:bool enable[11] ={ phl->lsm.ompa, phl->lsm.ouci, phl->lsm.ofdi, phl->lsm.oedd, phl->lsm.onbr,
./src/higher-level/lsm-hl.c:                    phl->lsm.oems, phl->lsm.oavg, phl->lsm.ostd, phl->lsm.ogeo, phl->lsm.omax, phl->lsm.oare };
./src/higher-level/lsm-hl.c:bool write[11]  ={ phl->lsm.ompa, phl->lsm.ouci, phl->lsm.ofdi, phl->lsm.oedd, phl->lsm.onbr,
./src/higher-level/lsm-hl.c:                    phl->lsm.oems, phl->lsm.oavg, phl->lsm.ostd, phl->lsm.ogeo, phl->lsm.omax, phl->lsm.oare };
./src/higher-level/lsm-hl.c:          basename_without_ext(phl->ftr.bname[b], bname, NPOW_10);
./src/higher-level/lsm-hl.c:            nchar = snprintf(domain, NPOW_10, "%s_B%04d", bname, phl->ftr.band[b]);
./src/higher-level/lsm-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher,
./src/higher-level/lsm-hl.c:  nchar = snprintf(fname, NPOW_10, "%s_HL_LSM_%s", phl->lsm.base, prodname);
./src/higher-level/lsm-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/lsm-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/lsm-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/lsm-hl.c:int kernelSize = (phl->lsm.radius * 2 + 1) * (phl->lsm.radius * 2 + 1);
./src/higher-level/lsm-hl.c:int minPatchSize = phl->lsm.minpatchsize;
./src/higher-level/lsm-hl.c:  width = phl->lsm.radius*2+1;
./src/higher-level/lsm-hl.c:        if (phl->lsm.ompa) lsm.mpa_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.ouci) lsm.uci_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.ofdi) lsm.fdi_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.oedd) lsm.edd_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.onbr) lsm.nbr_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.oems) lsm.ems_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.oavg) lsm.avg_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.ostd) lsm.std_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.ogeo) lsm.geo_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.omax) lsm.max_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (phl->lsm.oare) lsm.are_[f][p] = nodata;
./src/higher-level/lsm-hl.c:        if (!features[f].msk[p] && phl->ftr.exclude) continue;
./src/higher-level/lsm-hl.c:        switch (phl->lsm.query[f]){
./src/higher-level/lsm-hl.c:            if (features[f].dat[0][p] == phl->lsm.threshold[f]) newFeatures[p] = true;
./src/higher-level/lsm-hl.c:            if (features[f].dat[0][p] > phl->lsm.threshold[f]) newFeatures[p] = true;
./src/higher-level/lsm-hl.c:            if (features[f].dat[0][p] >= phl->lsm.threshold[f]) newFeatures[p] = true;
./src/higher-level/lsm-hl.c:            if (features[f].dat[0][p] < phl->lsm.threshold[f]) newFeatures[p] = true;
./src/higher-level/lsm-hl.c:            if (features[f].dat[0][p] <= phl->lsm.threshold[f]) newFeatures[p] = true;
./src/higher-level/lsm-hl.c:        if (!features[f].msk[p] && phl->ftr.exclude) continue;
./src/higher-level/lsm-hl.c:        if (!newFeatures[p] && !phl->lsm.allpx) continue;
./src/higher-level/lsm-hl.c:        for (ii=-phl->lsm.radius, ki=0; ii<=phl->lsm.radius; ii++, ki++){
./src/higher-level/lsm-hl.c:        for (jj=-phl->lsm.radius, kj=0; jj<=phl->lsm.radius; jj++, kj++){
./src/higher-level/lsm-hl.c:          if (phl->lsm.kernel == _KERNEL_CIRCLE_ && 
./src/higher-level/lsm-hl.c:              KDIST[ki][kj] > phl->lsm.radius) continue;
./src/higher-level/lsm-hl.c:          if (!features[f].msk[np] && phl->ftr.exclude) continue;
./src/higher-level/lsm-hl.c:          if (ii != phl->lsm.radius && ni+1 < ny &&
./src/higher-level/lsm-hl.c:          if (ii != -phl->lsm.radius && ni-1 >= 0 &&
./src/higher-level/lsm-hl.c:          if (jj != phl->lsm.radius && nj+1 < nx &&
./src/higher-level/lsm-hl.c:          if (jj != -phl->lsm.radius && nj-1 >= 0 &&
./src/higher-level/lsm-hl.c:        if (phl->lsm.ouci) lsm.uci_[f][p] = CCL[p];
./src/higher-level/lsm-hl.c:        if (phl->lsm.oavg) lsm.avg_[f][p] = mx;
./src/higher-level/lsm-hl.c:        if (phl->lsm.ogeo) lsm.geo_[f][p] = exp(logSum / (float)logCounter);
./src/higher-level/lsm-hl.c:        if (phl->lsm.omax) lsm.max_[f][p] = maxVal;
./src/higher-level/lsm-hl.c:        if (phl->lsm.oare){
./src/higher-level/lsm-hl.c:        if (phl->lsm.ostd) lsm.std_[f][p] = standdev(vx, validDataPixels);
./src/higher-level/lsm-hl.c:        if (phl->lsm.ompa){
./src/higher-level/lsm-hl.c:        if (phl->lsm.oedd) lsm.edd_[f][p] = (short)(totaledgelength / sqrt(kernelSize) * 10000);
./src/higher-level/lsm-hl.c:        if (phl->lsm.onbr) lsm.nbr_[f][p] = numberOfuniquePatches;
./src/higher-level/lsm-hl.c:        if (phl->lsm.oems) lsm.ems_[f][p] = (short)(totalClassArea * totalClassArea * 10000);
./src/higher-level/lsm-hl.c:          if (phl->lsm.ofdi) lsm.fdi_[f][p] = (short) (sumFractalDims / sumshare * 10000);
./src/higher-level/lsm-hl.c:          if (phl->lsm.ofdi) lsm.fdi_[f][p] = 0;
./src/higher-level/polar-hl.c:  if (phl->tsa.pol.opct +
./src/higher-level/polar-hl.c:      phl->tsa.pol.opol +
./src/higher-level/polar-hl.c:      phl->tsa.pol.otrd +
./src/higher-level/polar-hl.c:      phl->tsa.pol.ocat == 0) return SUCCESS;
./src/higher-level/polar-hl.c:    phl->date_range[_MIN_].year, phl->date_range[_MAX_].year, &phl->tsa.tsi, &phl->tsa.pol) == FAILURE) return FAILURE;
./src/higher-level/tasks-hl.c:  omp_set_num_threads(phl->ithread);
./src/higher-level/tasks-hl.c:  if (phl->input_level1 == _INP_FTR_){
./src/higher-level/tasks-hl.c:  } else if (phl->input_level1 == _INP_CON_){
./src/higher-level/tasks-hl.c:  } else if (phl->input_level1 == _INP_ARD_ || phl->input_level1 == _INP_QAI_){
./src/higher-level/tasks-hl.c:      pro->tx_next, pro->ty_next, pro->chunk_next, cube, &phl->sen, phl);
./src/higher-level/tasks-hl.c:  } else if (phl->input_level1 != _INP_NONE_) {
./src/higher-level/tasks-hl.c:  if (phl->input_level2 == _INP_FTR_){
./src/higher-level/tasks-hl.c:  } else if (phl->input_level2 == _INP_CON_){
./src/higher-level/tasks-hl.c:  } else if (phl->input_level2 == _INP_ARD_ || phl->input_level2 == _INP_QAI_){
./src/higher-level/tasks-hl.c:      pro->tx_next, pro->ty_next, pro->chunk_next, cube, &phl->sen2, phl);
./src/higher-level/tasks-hl.c:  } else if (phl->input_level2 != _INP_NONE_){
./src/higher-level/tasks-hl.c:  omp_set_num_threads(phl->cthread);
./src/higher-level/tasks-hl.c:    if (screen_qai(ARD1[pro->pu], nt1[pro->pu], MASK[pro->pu], &phl->qai, phl->input_level1) != SUCCESS) error = true;
./src/higher-level/tasks-hl.c:    if (phl->input_level1 == _INP_ARD_ || phl->input_level1 == _INP_QAI_){
./src/higher-level/tasks-hl.c:      if (screen_noise(ARD1[pro->pu], nt1[pro->pu], MASK[pro->pu], &phl->qai) == FAILURE) error = true;
./src/higher-level/tasks-hl.c:    if (screen_qai(ARD2[pro->pu], nt2[pro->pu], MASK[pro->pu], &phl->qai, phl->input_level2) != SUCCESS) error = true;
./src/higher-level/tasks-hl.c:    if (phl->input_level2 == _INP_ARD_ || phl->input_level2 == _INP_QAI_){
./src/higher-level/tasks-hl.c:      if (screen_noise(ARD2[pro->pu], nt2[pro->pu], MASK[pro->pu], &phl->qai) == FAILURE) error = true;
./src/higher-level/tasks-hl.c:  if (!error && phl->input_level1 == _INP_ARD_){
./src/higher-level/tasks-hl.c:    switch (phl->type){
./src/higher-level/tasks-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, pro->tx_prev, pro->ty_prev);
./src/higher-level/tasks-hl.c:    omp_set_num_threads(phl->othread);
./src/higher-level/tasks-hl.c:        if (phl->radius > 0) OUTPUT[pro->pu_prev][o] = crop_brick(
./src/higher-level/tasks-hl.c:          OUTPUT[pro->pu_prev][o], phl->radius);
./src/higher-level/tsa-hl.c:  info[o].write    = phl->tsa.otss;
./src/higher-level/tsa-hl.c:  info[o].write    = phl->tsa.tsi.otsi;
./src/higher-level/tsa-hl.c:  info[o].prodlen  = phl->tsa.stm.sta.nmetrics;
./src/higher-level/tsa-hl.c:  info[o].enable   = phl->tsa.stm.ostm;
./src/higher-level/tsa-hl.c:  info[o].write    = phl->tsa.stm.ostm;
./src/higher-level/tsa-hl.c:  info[o].enable   = phl->tsa.sma.orms;
./src/higher-level/tsa-hl.c:  info[o].write    = phl->tsa.sma.orms;
./src/higher-level/tsa-hl.c:  info[o].enable   = phl->tsa.lsp.ospl;
./src/higher-level/tsa-hl.c:  info[o].write    = phl->tsa.lsp.ospl;
./src/higher-level/tsa-hl.c:  info[p].prodlen  = phl->ny;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ofby+phl->tsa.fld.otry+phl->tsa.fld.ocay;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ofby;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.otry;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.otry;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ocay;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ocay;
./src/higher-level/tsa-hl.c:  info[p].prodlen  = phl->nq;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ofbq+phl->tsa.fld.otrq+phl->tsa.fld.ocaq;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ofbq;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.otrq;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.otrq;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ocaq;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ocaq;
./src/higher-level/tsa-hl.c:  info[p].prodlen  = phl->nm;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ofbm+phl->tsa.fld.otrm+phl->tsa.fld.ocam;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ofbm;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.otrm;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.otrm;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ocam;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ocam;
./src/higher-level/tsa-hl.c:  info[p].prodlen  = phl->nw;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ofbw+phl->tsa.fld.otrw+phl->tsa.fld.ocaw;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ofbw;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.otrw;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.otrw;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ocaw;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ocaw;
./src/higher-level/tsa-hl.c:  info[p].prodlen  = phl->nd;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ofbd+phl->tsa.fld.otrd+phl->tsa.fld.ocad;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ofbd;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.otrd;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.otrd;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.fld.ocad;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.fld.ocad;
./src/higher-level/tsa-hl.c:    info[p].prodlen  = phl->tsa.lsp.ny;
./src/higher-level/tsa-hl.c:    info[p].enable   = phl->tsa.lsp.use[l]*(phl->tsa.lsp.olsp+phl->tsa.lsp.otrd+phl->tsa.lsp.ocat);
./src/higher-level/tsa-hl.c:    info[p].write    = phl->tsa.lsp.use[l]*phl->tsa.lsp.olsp;
./src/higher-level/tsa-hl.c:    info[p].enable   = phl->tsa.lsp.use[l]*phl->tsa.lsp.otrd;
./src/higher-level/tsa-hl.c:    info[p].write    = phl->tsa.lsp.use[l]*phl->tsa.lsp.otrd;
./src/higher-level/tsa-hl.c:    info[p].enable   = phl->tsa.lsp.use[l]*phl->tsa.lsp.ocat;
./src/higher-level/tsa-hl.c:    info[p].write    = phl->tsa.lsp.use[l]*phl->tsa.lsp.ocat;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.pol.opct;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.pol.opct;
./src/higher-level/tsa-hl.c:  info[p].enable   = phl->tsa.pol.opct;
./src/higher-level/tsa-hl.c:  info[p].write    = phl->tsa.pol.opct;
./src/higher-level/tsa-hl.c:    info[p].prodlen  = phl->tsa.pol.ny;
./src/higher-level/tsa-hl.c:    info[p].enable   = phl->tsa.pol.use[l]*(phl->tsa.pol.opol+phl->tsa.pol.otrd+phl->tsa.pol.ocat);
./src/higher-level/tsa-hl.c:    info[p].write    = phl->tsa.pol.use[l]*phl->tsa.pol.opol;
./src/higher-level/tsa-hl.c:    info[p].enable   = phl->tsa.pol.use[l]*phl->tsa.pol.otrd;
./src/higher-level/tsa-hl.c:    info[p].write    = phl->tsa.pol.use[l]*phl->tsa.pol.otrd;
./src/higher-level/tsa-hl.c:    info[p].enable   = phl->tsa.pol.use[l]*phl->tsa.pol.ocat;
./src/higher-level/tsa-hl.c:    info[p].write    = phl->tsa.pol.use[l]*phl->tsa.pol.ocat;
./src/higher-level/tsa-hl.c:  info[o].prodlen  = phl->tsa.pyp.nb;
./src/higher-level/tsa-hl.c:  info[o].bandname = phl->tsa.pyp.bandname;
./src/higher-level/tsa-hl.c:  info[o].date     = phl->tsa.pyp.date;
./src/higher-level/tsa-hl.c:  info[o].enable   = phl->tsa.pyp.out;
./src/higher-level/tsa-hl.c:  info[o].write    = phl->tsa.pyp.out;
./src/higher-level/tsa-hl.c:    nt,ni,phl->ny,phl->nq,phl->nm,phl->nw,phl->nd,phl->tsa.lsp.ny);
./src/higher-level/tsa-hl.c:  if (phl->ny         > 0) alloc((void**)&ts->d_fby, phl->ny, sizeof(date_t));         else ts->d_fby = NULL;
./src/higher-level/tsa-hl.c:  if (phl->nq         > 0) alloc((void**)&ts->d_fbq, phl->nq, sizeof(date_t));         else ts->d_fbq = NULL;
./src/higher-level/tsa-hl.c:  if (phl->nm         > 0) alloc((void**)&ts->d_fbm, phl->nm, sizeof(date_t));         else ts->d_fbm = NULL;
./src/higher-level/tsa-hl.c:  if (phl->nw         > 0) alloc((void**)&ts->d_fbw, phl->nw, sizeof(date_t));         else ts->d_fbw = NULL;
./src/higher-level/tsa-hl.c:  if (phl->nd         > 0) alloc((void**)&ts->d_fbd, phl->nd, sizeof(date_t));         else ts->d_fbd = NULL;
./src/higher-level/tsa-hl.c:  if (phl->tsa.lsp.ny > 0) alloc((void**)&ts->d_lsp, phl->tsa.lsp.ny, sizeof(date_t)); else ts->d_lsp = NULL;
./src/higher-level/tsa-hl.c:  if (phl->tsa.pol.ny > 0) alloc((void**)&ts->d_pol, phl->tsa.pol.ny, sizeof(date_t)); else ts->d_pol = NULL;
./src/higher-level/tsa-hl.c:      if (phl->tsa.tsi.method == _INT_NONE_){
./src/higher-level/tsa-hl.c:        set_date_ce(&date, phl->date_range[_MIN_].ce + t*phl->tsa.tsi.step);
./src/higher-level/tsa-hl.c:  if (phl->ny > 0){
./src/higher-level/tsa-hl.c:    for (t=0; t<phl->ny; t++){
./src/higher-level/tsa-hl.c:      set_date_year(&date, phl->date_range[_MIN_].year+t);
./src/higher-level/tsa-hl.c:  if (phl->nq > 0){
./src/higher-level/tsa-hl.c:    for (t=0, k=1; t<phl->nq; t++){
./src/higher-level/tsa-hl.c:      while (k < 5 && !phl->date_quarters[k]) k++;
./src/higher-level/tsa-hl.c:  if (phl->nm > 0){
./src/higher-level/tsa-hl.c:    for (t=0, k=1; t<phl->nm; t++){
./src/higher-level/tsa-hl.c:      while (k < 13 && !phl->date_months[k]) k++;
./src/higher-level/tsa-hl.c:  if (phl->nw > 0){
./src/higher-level/tsa-hl.c:    for (t=0, k=1; t<phl->nw; t++){
./src/higher-level/tsa-hl.c:      while (k < 53 && !phl->date_weeks[k]) k++;
./src/higher-level/tsa-hl.c:  if (phl->nd > 0){
./src/higher-level/tsa-hl.c:    for (t=0, k=1; t<phl->nd; t++){
./src/higher-level/tsa-hl.c:      while (k < 366 && !phl->date_doys[k]) k++;
./src/higher-level/tsa-hl.c:  if (phl->tsa.lsp.ny > 0){
./src/higher-level/tsa-hl.c:    for (t=0; t<phl->tsa.lsp.ny; t++){
./src/higher-level/tsa-hl.c:      set_date_year(&date, phl->date_range[_MIN_].year+t+1);
./src/higher-level/tsa-hl.c:  if (phl->tsa.pol.ny > 0){
./src/higher-level/tsa-hl.c:    for (t=0; t<phl->tsa.pol.ny; t++){
./src/higher-level/tsa-hl.c:      set_date_year(&date, phl->date_range[_MIN_].year+t);
./src/higher-level/tsa-hl.c:              set_brick_bandname(TSA[o], t, _TAGGED_ENUM_STA_[phl->tsa.stm.sta.metrics[t]].tag);
./src/higher-level/tsa-hl.c:              if (phl->tsa.tsi.method == _INT_NONE_){
./src/higher-level/tsa-hl.c:                set_date_ce(&date, phl->date_range[_MIN_].ce + t*phl->tsa.tsi.step);
./src/higher-level/tsa-hl.c:              set_date_year(&date, phl->date_range[_MIN_].year+t);
./src/higher-level/tsa-hl.c:              while (k < 5 && !phl->date_quarters[k]) k++;
./src/higher-level/tsa-hl.c:              while (k < 13 && !phl->date_months[k]) k++;
./src/higher-level/tsa-hl.c:              while (k < 53 && !phl->date_weeks[k]) k++;
./src/higher-level/tsa-hl.c:              while (k < 366 && !phl->date_doys[k]) k++;
./src/higher-level/tsa-hl.c:              set_date_year(&date, phl->date_range[_MIN_].year+t+1);
./src/higher-level/tsa-hl.c:              set_date_year(&date, phl->date_range[_MIN_].year+t);
./src/higher-level/tsa-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/tsa-hl.c:    phl->date_range[_MIN_].year, phl->date_range[_MAX_].year, 
./src/higher-level/tsa-hl.c:    phl->doy_range[_MIN_], phl->doy_range[_MAX_], 
./src/higher-level/tsa-hl.c:    phl->sen.target, phl->tsa.index_name[idx], info->prodname);
./src/higher-level/tsa-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/tsa-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/tsa-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/tsa-hl.c:  sprintf(domain, "%s_%s", phl->tsa.index_name[idx], info->prodname);
./src/higher-level/tsa-hl.c://  printf("allocating %d indices\n", phl->tsa.n);
./src/higher-level/tsa-hl.c:  alloc((void**)&TSA, phl->tsa.n, sizeof(brick_t**));
./src/higher-level/tsa-hl.c:  if (phl->tsa.tsi.method == _INT_NONE_){
./src/higher-level/tsa-hl.c:    ni = ceil((phl->date_range[_MAX_].ce-phl->date_range[_MIN_].ce+1)/phl->tsa.tsi.step);
./src/higher-level/tsa-hl.c:  for (idx=0; idx<phl->tsa.n; idx++){
./src/higher-level/tsa-hl.c:    init_pyp(NULL, &ts, _HL_TSA_, phl->tsa.index_name[idx], 1, ni, &phl->tsa.pyp);
./src/higher-level/tsa-hl.c:    tsa_spectral_index(ard, &ts, mask_, nc, nt, idx, nodata, &phl->tsa, &phl->sen, endmember);
./src/higher-level/tsa-hl.c:    tsa_interpolation(&ts, mask_, nc, nt, ni, nodata, &phl->tsa.tsi);
./src/higher-level/tsa-hl.c:    python_udf(NULL, NULL, &ts, mask_, _HL_TSA_, phl->tsa.index_name[idx], 
./src/higher-level/tsa-hl.c:      nx, ny, nc, 1, ni, nodata, &phl->tsa.pyp, phl->cthread);
./src/higher-level/tsa-hl.c:    tsa_stm(&ts, mask_, nc, ni, nodata, &phl->tsa.stm);
./src/higher-level/tsa-hl.c:    term_pyp(&phl->tsa.pyp);
./src/higher-level/tsa-hl.c:  alloc((void**)&PTR, phl->tsa.n*nprod, sizeof(brick_t*));
./src/higher-level/tsa-hl.c:  for (idx=0, k=0; idx<phl->tsa.n; idx++){
./src/higher-level/tsa-hl.c:  for (idx=0; idx<phl->tsa.n; idx++) free((void*)TSA[idx]);
./src/higher-level/tsa-hl.c:  *nproduct = nprod*phl->tsa.n;
./src/higher-level/lib-hl.c:            basename_without_ext(phl->lib.f_lib[b], bname, NPOW_10);
./src/higher-level/lib-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher,
./src/higher-level/lib-hl.c:  nchar = snprintf(fname, NPOW_10, "%s_HL_LSM_%s", phl->lib.base, prodname);
./src/higher-level/lib-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/lib-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/lib-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/lib-hl.c:        if (!features[f].msk[p] && phl->ftr.exclude) valid = false;
./src/higher-level/lib-hl.c:          if (phl->lib.rescale){
./src/higher-level/lib-hl.c:        if (min_mae < SHRT_MAX && phl->lib.rescale) min_mae *= 1000;
./src/higher-level/lib-hl.c:      if (min_mae_all < SHRT_MAX && phl->lib.rescale) min_mae_all *= 1000;
./src/higher-level/udf-hl.c:  info[o].prodlen  = phl->udf.pyp.nb;
./src/higher-level/udf-hl.c:  info[o].bandname = phl->udf.pyp.bandname;
./src/higher-level/udf-hl.c:  info[o].date     = phl->udf.pyp.date;
./src/higher-level/udf-hl.c:  info[o].enable   = phl->udf.pyp.out;
./src/higher-level/udf-hl.c:  info[o].write    = phl->udf.pyp.out;
./src/higher-level/udf-hl.c:  info[o].prodlen  = phl->udf.rsp.nb;
./src/higher-level/udf-hl.c:  info[o].bandname = phl->udf.rsp.bandname;
./src/higher-level/udf-hl.c:  info[o].date     = phl->udf.rsp.date;
./src/higher-level/udf-hl.c:  info[o].enable   = phl->udf.rsp.out;
./src/higher-level/udf-hl.c:  info[o].write    = phl->udf.rsp.out;
./src/higher-level/udf-hl.c:  nchar = snprintf(dname, NPOW_10, "%s/X%04d_Y%04d", phl->d_higher, 
./src/higher-level/udf-hl.c:    phl->date_range[_MIN_].year, phl->date_range[_MAX_].year, 
./src/higher-level/udf-hl.c:    phl->doy_range[_MIN_], phl->doy_range[_MAX_], 
./src/higher-level/udf-hl.c:    phl->sen.target, info->prodname);
./src/higher-level/udf-hl.c:  set_brick_format(brick, phl->format);
./src/higher-level/udf-hl.c:  set_brick_explode(brick, phl->explode);
./src/higher-level/udf-hl.c:  set_brick_par(brick, phl->params->log);
./src/higher-level/udf-hl.c:  init_pyp(ard, NULL, _HL_UDF_, NULL, nb, nt, &phl->udf.pyp);
./src/higher-level/udf-hl.c:    nx, ny, nc, nb, nt, nodata, &phl->udf.pyp, phl->cthread);
./src/higher-level/udf-hl.c:  term_pyp(&phl->udf.pyp);
./src/higher-level/sample-hl.c:  if (phl->smp.projected){
./src/higher-level/sample-hl.c:      if (phl->smp.projected){
./src/higher-level/sample-hl.c:        if (!features[f].msk[p] && phl->ftr.exclude) valid = false;
./src/higher-level/sample-hl.c:    append_table(phl->smp.f_sample,   copied, smp_features, smp->ns, nf, 0);
./src/higher-level/sample-hl.c:    append_table(phl->smp.f_response, copied, smp_response, smp->ns, nr, 6);
./src/higher-level/sample-hl.c:    append_table(phl->smp.f_coords,   copied, smp->tab,     smp->ns, 2,  6);
